<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARIAN W≈ÅODARSKI GESUNDHEIT FUSSBALL 2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(45deg, #0d4a2d, #1a5c36, #0d4a2d);
            font-family: 'Orbitron', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #00ff00;
        }

        h1 {
            color: #ffff00;
            text-shadow: 3px 3px 0px #ff0000, 6px 6px 10px rgba(0,0,0,0.8);
            margin-bottom: 5px;
            font-weight: 900;
            font-size: 24px;
            letter-spacing: 2px;
            text-align: center;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 3px 3px 0px #ff0000, 6px 6px 10px rgba(0,0,0,0.8), 0 0 20px #ffff00; }
            to { text-shadow: 3px 3px 0px #ff0000, 6px 6px 10px rgba(0,0,0,0.8), 0 0 40px #ffff00, 0 0 60px #ffff00; }
        }

        .subtitle {
            color: #00ffff;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            margin-bottom: 10px;
            text-align: center;
        }

        .round-info {
            background: linear-gradient(45deg, #000033, #000066);
            border: 3px solid #ff4444;
            padding: 8px 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            text-align: center;
            color: #ffff00;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(255,68,68,0.5);
        }

        .score {
            background: linear-gradient(45deg, #000033, #000066);
            border: 3px solid #00ff00;
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,255,0,0.3);
        }

        .team-name {
            font-size: 12px;
            color: #ffff00;
        }

        .game-container {
            position: relative;
            border: 8px solid #8B4513;
            border-radius: 15px;
            background: #228B22;
            box-shadow: 0 0 30px rgba(0,0,0,0.8), inset 0 0 20px rgba(139,69,19,0.5);
        }

        #gameCanvas {
            display: block;
            border-radius: 8px;
        }

        .controls {
            background: linear-gradient(45deg, #000033, #000066);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
        }

        .reset-btn, .next-btn, #retryRoundBtn {
            background: linear-gradient(45deg, #ff0000, #ff4444);
            color: #ffff00;
            border: 3px solid #ffff00;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .next-btn {
            background: linear-gradient(45deg, #00aa00, #00ff00);
            color: #000033;
            border-color: #ffff00;
        }

        .reset-btn:hover, .next-btn:hover, #retryRoundBtn:hover {
            box-shadow: 0 0 15px rgba(255,255,0,0.5);
        }

        .difficulty-btn {
            display: none;
        }

        .winner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #000066, #000099);
            border: 4px solid #ffff00;
            color: #00ff00;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            box-shadow: 0 0 30px rgba(255,255,0,0.5);
        }

        .start-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #000066, #000099);
            border: 4px solid #00ff00;
            color: #ffff00;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            box-shadow: 0 0 30px rgba(0,255,0,0.5);
        }

        .retro-text {
            color: #00ffff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>üèÜ MARIAN W≈ÅODARSKI GESUNDHEIT FUSSBALL 2 üèÜ</h1>
    <div class="subtitle">*** ZWEITE BUNDESLIGA EDITION 1995 ***</div>
    
    <div class="round-info" id="roundInfo">
        RUNDE 1: SV BABELSBERG 04 vs VFL OLDENBURG
    </div>
    
    <div class="score">
        <div class="team-name" id="playerTeam">SV BABELSBERG 04</div>
        <span id="playerScore">0</span> : <span id="botScore">0</span>
        <div class="team-name" id="botTeam">VFL OLDENBURG</div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="startMessage" class="start-message">
            <h3 id="startTitle">üöÄ DR√úCKEN SIE LEERTASTE! üöÄ</h3>
            <p class="retro-text">WASD = STEUERUNG</p>
            <p id="startSubtitle">*** ERSTE RUNDE BEGINNT! ***</p>
        </div>
        <div id="winnerMessage" class="winner" style="display: none;"></div>
    </div>

    <div class="controls">
        <p class="retro-text"><strong>MARIAN W≈ÅODARSKI:</strong> WASD + SPACJA (KOPNIƒòCIE) | <strong>GEGNER:</strong> COMPUTER KI</p>
        <p>LEERTASTE: START/RESET BALL | KOPNIƒòCIE (zielona aureola) | ERSTER BIS 5 TORE GEWINNT!</p>
        <p style="font-size: 10px; color: #ffaa00;">*** RUNDE 1: BEIDE NUR EIGENE H√ÑLFTE | AB RUNDE 2: MARIAN FREI! ***</p>
        
        <button class="reset-btn" onclick="resetGame()">üîÑ NEUES TURNIER</button>
        <button class="next-btn" id="nextRoundBtn" onclick="nextRound()" style="display: none;">‚û°Ô∏è N√ÑCHSTE RUNDE</button>
        <button class="reset-btn" id="retryRoundBtn" onclick="retryRound()" style="display: none;">üîÑ RUNDE WIEDERHOLEN</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Definicje rund turniejowych
        const rounds = [
            {
                number: 1,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "VFL OLDENBURG",
                field: "grass",
                bots: [
                    { name: "HANS JURGEN", x: 700, y: 200, color: "#0000ff", maxSpeed: 5, aggressiveness: 0.7, canCrossHalf: false }
                ]
            },
            {
                number: 2, 
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "SV WALDORF MANNHEIM",
                field: "muddy",
                bots: [
                    { name: "KLAUS SCHMIDT", x: 700, y: 200, color: "#800080", maxSpeed: 6, aggressiveness: 0.8, canCrossHalf: true }
                ]
            },
            {
                number: 3,
                playerTeam: "SV BABELSBERG 04", 
                opponentTeam: "FC HANSA ROSTOCK",
                field: "winter",
                bots: [
                    { name: "WERNER M√úLLER", x: 650, y: 150, color: "#006600", maxSpeed: 6, aggressiveness: 0.8, canCrossHalf: true },
                    { name: "FRITZ WAGNER", x: 650, y: 250, color: "#006600", maxSpeed: 5, aggressiveness: 0.7, canCrossHalf: false }
                ]
            },
            {
                number: 4,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "EINTRACHT BRAUNSCHWEIG", 
                field: "professional",
                bots: [
                    { name: "G√úNTER HOFFMAN", x: 600, y: 120, color: "#ff6600", maxSpeed: 7, aggressiveness: 0.9, canCrossHalf: true },
                    { name: "DIETER KLEIN", x: 650, y: 200, color: "#ff6600", maxSpeed: 6, aggressiveness: 0.8, canCrossHalf: false },
                    { name: "STEFAN BRAUN", x: 600, y: 280, color: "#ff6600", maxSpeed: 7, aggressiveness: 0.9, canCrossHalf: false }
                ]
            },
            {
                number: 5,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "LOKOMOTIV LEIPZIG",
                field: "stadium", 
                bots: [
                    { name: "WOLFGANG RICHTER", x: 600, y: 100, color: "#990000", maxSpeed: 8, aggressiveness: 1.0, canCrossHalf: true },
                    { name: "HERMANN FISCHER", x: 650, y: 200, color: "#990000", maxSpeed: 7, aggressiveness: 0.9, canCrossHalf: false },
                    { name: "RUDOLF BECKER", x: 600, y: 300, color: "#990000", maxSpeed: 8, aggressiveness: 1.0, canCrossHalf: false },
                    { name: "OTTO SCHULZ", x: 750, y: 200, color: "#660000", maxSpeed: 3, aggressiveness: 0.4, isGoalkeeper: true, canCrossHalf: false }
                ]
            }
        ];

        // Stan gry z efektami
        let gameState = {
            playerScore: 0,
            botScore: 0,
            gameWon: false,
            gameStarted: false,
            ballInPlay: false,
            currentRound: 0,
            roundWon: false,
            particles: [],
            ballRotation: 0,
            screenShake: 0
        };

        // Gracz (Marian W≈Çodarski) - bez cooldown
        const player = {
            x: 100,
            y: canvas.height / 2,
            radius: 20,
            color: '#ff0000',
            vx: 0,
            vy: 0,
            kickRange: 35
        };

        // Boty - bƒôdƒÖ ≈Çadowane z definicji rund
        let bots = [];

        // Pi≈Çka (mniejsza)
        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 8,
            vx: 0,
            vy: 0,
            color: '#ffffff',
            maxSpeed: 18,
            startSpeed: 9
        };

        // Sterowanie
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                if (!gameState.gameStarted) {
                    startGame();
                } else if (!gameState.ballInPlay && !gameState.gameWon) {
                    launchBall();
                } else if (gameState.ballInPlay && canPlayerKick()) {
                    // Proste kopniƒôcie!
                    playerKick();
                }
            }
        });

        // Proste funkcje kopniƒôcia
        function canPlayerKick() {
            const distanceToBall = Math.sqrt((ball.x - player.x) ** 2 + (ball.y - player.y) ** 2);
            return distanceToBall <= player.kickRange;
        }

        function playerKick() {
            // Oblicz kierunek od gracza do pi≈Çki (fizyka!)
            const dx = ball.x - player.x;
            const dy = ball.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                // Normalizuj kierunek
                const directionX = dx / distance;
                const directionY = dy / distance;
                
                // Kopnij z mocƒÖ! (jak prawdziwe kopniƒôcie)
                const kickPower = 12;
                ball.vx = directionX * kickPower;
                ball.vy = directionY * kickPower;
                
                // Ograniczenie maksymalnej prƒôdko≈õci
                const newSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (newSpeed > ball.maxSpeed) {
                    ball.vx = (ball.vx / newSpeed) * ball.maxSpeed;
                    ball.vy = (ball.vy / newSpeed) * ball.maxSpeed;
                }
            }
        }

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Efekty czƒÖsteczkowe
        function createParticles(x, y, color, count) {
            for(let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function createGoalEffect(x, y) {
            for(let i = 0; i < 20; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 60,
                    maxLife: 60,
                    color: '#ffff00',
                    size: Math.random() * 8 + 4
                });
            }
            gameState.screenShake = 8;
        }

        function updateParticles() {
            for(let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if(particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            gameState.particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `rgba(255,255,0,${alpha})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateEffects() {
            updateParticles();
            if(gameState.screenShake > 0) {
                gameState.screenShake *= 0.9;
                if(gameState.screenShake < 0.1) gameState.screenShake = 0;
            }
        }

        // Funkcje rysowania r√≥≈ºnych boisk
        function drawField() {
            const currentRoundData = rounds[gameState.currentRound];
            
            switch(currentRoundData.field) {
                case 'grass':
                    drawGrassField();
                    break;
                case 'muddy':
                    drawMuddyField();
                    break;
                case 'winter':
                    drawWinterField();
                    break;
                case 'professional':
                    drawProfessionalField();
                    break;
                case 'stadium':
                    drawStadiumField();
                    break;
            }
        }

        function drawGrassField() {
            // Zielone boisko z realistycznymi zniszczeniami
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#32CD32');
            gradient.addColorStop(0.7, '#228B22');
            gradient.addColorStop(1, '#1F7A1F');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Tekstura trawy
            ctx.strokeStyle = 'rgba(50, 205, 50, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            // B≈Çoto pod bramkami
            ctx.fillStyle = 'rgba(139,69,19,0.6)';
            ctx.beginPath();
            ctx.ellipse(60, canvas.height/2, 50, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(canvas.width - 60, canvas.height/2, 50, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Starta murawa
            ctx.fillStyle = 'rgba(101,67,33,0.4)';
            const spots = [{x:300,y:100,w:25,h:15}, {x:500,y:320,w:30,h:20}, {x:150,y:250,w:20,h:25}, {x:650,y:150,w:35,h:18}];
            spots.forEach(spot => {
                ctx.beginPath();
                ctx.ellipse(spot.x, spot.y, spot.w, spot.h, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            drawStandardFieldLines();
        }

        function drawMuddyField() {
            // B≈Çotniste boisko
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(0.5, '#654321');
            gradient.addColorStop(1, '#2F1B0C');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ka≈Çu≈ºe
            ctx.fillStyle = 'rgba(0,100,150,0.7)';
            [[200,100,40,20], [600,300,35,25], [400,150,30,15]].forEach(([x,y,w,h]) => {
                ctx.beginPath();
                ctx.ellipse(x, y, w, h, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            drawStandardFieldLines();
        }

        function drawWinterField() {
            // Zimowe boisko
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#f8f8ff');
            gradient.addColorStop(0.7, '#e6f3ff');
            gradient.addColorStop(1, '#d0e8ff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // P≈Çatki ≈õniegu
            const time = Date.now() * 0.001;
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            for(let i = 0; i < 20; i++) {
                const x = (i * 37 + Math.sin(time + i) * 10) % canvas.width;
                const y = (i * 23 + time * 10) % canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 2 + Math.sin(time + i), 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawStandardFieldLines();
        }

        function drawProfessionalField() {
            // Profesjonalne boisko
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, '#228B22');
            gradient.addColorStop(0.5, '#32CD32');
            gradient.addColorStop(1, '#228B22');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Paski
            ctx.fillStyle = 'rgba(50, 205, 50, 0.5)';
            for (let i = 0; i < canvas.width; i += 80) {
                ctx.fillRect(i, 0, 40, canvas.height);
            }
            
            drawStandardFieldLines();
        }

        function drawStadiumField() {
            // Stadionowe boisko fina≈Çowe
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#00FF00');
            gradient.addColorStop(0.7, '#228B22');
            gradient.addColorStop(1, '#006400');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Paski stadionowe
            ctx.fillStyle = 'rgba(34, 139, 34, 0.3)';
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.fillRect(i, 0, 20, canvas.height);
            }
            
            // Reflektory
            const time = Date.now() * 0.001;
            ctx.fillStyle = `rgba(255,255,255,${0.1 + Math.sin(time) * 0.05})`;
            ctx.beginPath();
            ctx.arc(canvas.width/4, 50, 80, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(3*canvas.width/4, 50, 80, 0, Math.PI * 2);
            ctx.fill();
            
            drawStandardFieldLines();
        }

        function drawStandardFieldLines() {
            // Linie boiska
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;

            // Obramowanie
            ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

            // Linia ≈õrodkowa
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 10);
            ctx.lineTo(canvas.width / 2, canvas.height - 10);
            ctx.stroke();

            // Ko≈Ço ≈õrodkowe
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 60, 0, Math.PI * 2);
            ctx.stroke();

            // Punkt ≈õrodkowy
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 4, 0, Math.PI * 2);
            ctx.fill();

            drawGoalsAndBoxes();
        }

        function drawGoalsAndBoxes() {
            // Wyra≈∫niejsze bramki
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 10;
            
            // Lewa bramka
            ctx.beginPath();
            ctx.moveTo(10, canvas.height * 0.35);
            ctx.lineTo(10, canvas.height * 0.65);
            ctx.stroke();
            
            // Prawa bramka
            ctx.beginPath();
            ctx.moveTo(canvas.width - 10, canvas.height * 0.35);
            ctx.lineTo(canvas.width - 10, canvas.height * 0.65);
            ctx.stroke();
            
            // Pola bramkowe
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, canvas.height * 0.4, 40, canvas.height * 0.2);
            ctx.strokeRect(canvas.width - 50, canvas.height * 0.4, 40, canvas.height * 0.2);

            // Pola karne
            ctx.strokeRect(10, canvas.height * 0.25, 80, canvas.height * 0.5);
            ctx.strokeRect(canvas.width - 90, canvas.height * 0.25, 80, canvas.height * 0.5);

            // Punkty karne
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(70, canvas.height / 2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(canvas.width - 70, canvas.height / 2, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlayer(playerObj, name, isBot = false) {
            // Shake effect
            const shakeX = gameState.screenShake * (Math.random() - 0.5) * 2;
            const shakeY = gameState.screenShake * (Math.random() - 0.5) * 2;
            const drawX = playerObj.x + shakeX;
            const drawY = playerObj.y + shakeY;

            // Cie≈Ñ gracza
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.arc(drawX + 4, drawY + 4, playerObj.radius, 0, Math.PI * 2);
            ctx.fill();

            // Koszulka
            ctx.fillStyle = playerObj.color;
            ctx.beginPath();
            ctx.arc(drawX, drawY, playerObj.radius, 0, Math.PI * 2);
            ctx.fill();

            // Paski na koszulce
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            for(let i = -15; i <= 15; i += 8) {
                ctx.beginPath();
                ctx.moveTo(drawX + i, drawY - 15);
                ctx.lineTo(drawX + i, drawY + 15);
                ctx.stroke();
            }

            // Rƒôce
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(drawX - 12, drawY - 8, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(drawX + 12, drawY - 8, 4, 0, Math.PI * 2);
            ctx.fill();

            // Nogi
            ctx.fillStyle = playerObj.color;
            ctx.beginPath();
            ctx.arc(drawX - 6, drawY + 15, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(drawX + 6, drawY + 15, 5, 0, Math.PI * 2);
            ctx.fill();

            // Buty
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(drawX - 6, drawY + 18, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(drawX + 6, drawY + 18, 3, 0, Math.PI * 2);
            ctx.fill();

            // G≈Çowa
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(drawX, drawY - 12, 8, 0, Math.PI * 2);
            ctx.fill();

            // W≈Çosy
            ctx.fillStyle = isBot ? '#8B4513' : '#FFD700';
            ctx.beginPath();
            ctx.arc(drawX, drawY - 16, 6, 0, Math.PI);
            ctx.fill();

            // PROSTA AUREOLA KOPNIƒòCIA dla gracza
            if (!isBot && gameState.ballInPlay && canPlayerKick()) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(drawX, drawY, player.kickRange, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Aureola dla bot√≥w (normalna)
            if (isBot && gameState.ballInPlay) {
                const distanceToBall = Math.sqrt((ball.x - playerObj.x) ** 2 + (ball.y - playerObj.y) ** 2);
                let auraColor = '#00ff00';
                
                if (distanceToBall < 120) auraColor = '#ff4444';
                if (distanceToBall < 50) auraColor = '#ffff00';
                
                const pulse = Math.sin(Date.now() * 0.01) * 2 + 3;
                ctx.strokeStyle = auraColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(drawX, drawY, playerObj.radius + pulse, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Wska≈∫nik ograniczenia dla Mariana w rundzie 1
            if (gameState.currentRound === 0 && !isBot) {
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.arc(drawX, drawY, playerObj.radius + 12, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Wska≈∫nik ograniczenia dla bot√≥w
            if (isBot && !playerObj.canCrossHalf && !playerObj.isGoalkeeper) {
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.arc(drawX, drawY, playerObj.radius + 12, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Numer na koszulce
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Orbitron';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            const number = isBot ? '10' : '11';
            ctx.strokeText(number, drawX, drawY + 4);
            ctx.fillText(number, drawX, drawY + 4);

            // Nazwa gracza
            const nameY = drawY + playerObj.radius + 25;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(drawX - 35, nameY - 8, 70, 12);
            
            ctx.strokeStyle = isBot ? playerObj.color : '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(drawX - 35, nameY - 8, 70, 12);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 8px Orbitron';
            ctx.fillText(name, drawX, nameY);
        }

        function drawBall() {
            const shakeX = gameState.screenShake * (Math.random() - 0.5) * 2;
            const shakeY = gameState.screenShake * (Math.random() - 0.5) * 2;
            const drawX = ball.x + shakeX;
            const drawY = ball.y + shakeY;

            // ≈ölady za pi≈ÇkƒÖ
            if (gameState.ballInPlay && (Math.abs(ball.vx) > 2 || Math.abs(ball.vy) > 2)) {
                for(let i = 1; i <= 3; i++) {
                    const alpha = 0.3 - (i * 0.1);
                    const trailX = drawX - (ball.vx * i * 2);
                    const trailY = drawY - (ball.vy * i * 2);
                    
                    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, ball.radius - i, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Cie≈Ñ pi≈Çki
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.arc(drawX + 3, drawY + 3, ball.radius * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Pi≈Çka
            if (!gameState.ballInPlay && gameState.gameStarted && !gameState.gameWon) {
                if (Math.floor(Date.now() / 200) % 2) {
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                } else {
                    ctx.fillStyle = ball.color;
                }
            } else {
                ctx.fillStyle = ball.color;
            }
            
            ctx.beginPath();
            ctx.arc(drawX, drawY, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Wz√≥r pi≈Çki z rotacjƒÖ
            ctx.save();
            ctx.translate(drawX, drawY);
            ctx.rotate(gameState.ballRotation);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1.5;
            
            // Pentagramy
            ctx.beginPath();
            for(let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2 / 5);
                const x = Math.cos(angle) * ball.radius * 0.6;
                const y = Math.sin(angle) * ball.radius * 0.6;
                if(i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();

            ctx.restore();

            // Po≈Çysk
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.arc(drawX - ball.radius * 0.3, drawY - ball.radius * 0.3, ball.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Sterowanie graczem
        function updatePlayer() {
            const speed = 6;

            player.vx = 0;
            player.vy = 0;
            if (keys['w']) player.vy = -speed;
            if (keys['s']) player.vy = speed;
            if (keys['a']) player.vx = -speed;
            if (keys['d']) player.vx = speed;

            player.x += player.vx;
            player.y += player.vy;

            // Ograniczenia pozycji - od rundy 2 Marian mo≈ºe wszƒôdzie!
            if (gameState.currentRound === 0) {
                // Runda 1 - tylko swojƒÖ po≈Çowƒô
                player.x = Math.max(player.radius + 15, Math.min(canvas.width / 2 - 10, player.x));
            } else {
                // Runda 2+ - ca≈Çe boisko!
                player.x = Math.max(player.radius + 15, Math.min(canvas.width - player.radius - 15, player.x));
            }
            
            player.y = Math.max(player.radius + 15, Math.min(canvas.height - player.radius - 15, player.y));
        }

        // AI Bot√≥w - bez kopniƒôƒá na razie
        function updateBots() {
            bots.forEach(bot => {
                if (!gameState.ballInPlay && !bot.isGoalkeeper) {
                    const readyX = bot.isGoalkeeper ? canvas.width - 40 : canvas.width / 2 + 80;
                    const readyY = bot.isGoalkeeper ? canvas.height / 2 : bot.startY || canvas.height / 2;
                    
                    bot.vx = (readyX - bot.x) * 0.1;
                    bot.vy = (readyY - bot.y) * 0.1;
                    
                    bot.x += bot.vx;
                    bot.y += bot.vy;
                    return;
                }

                if (bot.isGoalkeeper) {
                    updateGoalkeeper(bot);
                } else {
                    updateFieldBot(bot);
                }
            });
        }

        function updateFieldBot(bot) {
            const distanceToBall = Math.sqrt((ball.x - bot.x) ** 2 + (ball.y - bot.y) ** 2);
            const ballInReach = distanceToBall < 120;
            
            let targetX, targetY;

            if (ballInReach || ball.x > canvas.width * 0.4) {
                const predictTime = 8;
                let futureX = ball.x + ball.vx * predictTime;
                let futureY = ball.y + ball.vy * predictTime;
                
                if (futureY < 25) futureY = 50 - futureY;
                if (futureY > canvas.height - 25) futureY = 2 * (canvas.height - 25) - futureY;
                
                targetX = futureX;
                targetY = futureY;
                
                if (distanceToBall < 50) {
                    const goalCenterY = canvas.height / 2;
                    const angleToGoal = Math.atan2(goalCenterY - ball.y, 20 - ball.x);
                    
                    targetX = ball.x + Math.cos(angleToGoal + Math.PI) * 25;
                    targetY = ball.y + Math.sin(angleToGoal + Math.PI) * 25;
                }
                
            } else {
                targetX = canvas.width / 2 + 60;
                
                if (ball.y < canvas.height / 3) {
                    targetY = canvas.height / 3;
                } else if (ball.y > canvas.height * 2/3) {
                    targetY = canvas.height * 2/3;
                } else {
                    targetY = ball.y;
                }
            }

            // System b≈Çƒôd√≥w dla r√≥≈ºnych rund
            let errorChance;
            switch(gameState.currentRound) {
                case 0: errorChance = 0.15; break; // Hans - najwiƒôksze b≈Çƒôdy
                case 1: errorChance = 0.10; break; // Klaus
                case 2: errorChance = 0.08; break; // Werner + Fritz
                case 3: errorChance = 0.06; break; // Eintracht (3 boty)
                case 4: errorChance = 0.04; break; // Leipzig (fina≈Ç)
                default: errorChance = 0.08;
            }
            
            if (Math.random() < errorChance) {
                targetX += (Math.random() - 0.5) * 80;
                targetY += (Math.random() - 0.5) * 80;
            }

            const dx = targetX - bot.x;
            const dy = targetY - bot.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 3) {
                const normalizedX = dx / distance;
                const normalizedY = dy / distance;
                
                let currentSpeed = bot.maxSpeed;
                if (ballInReach) currentSpeed *= 1.2; // Mniej boost speed
                if (distanceToBall < 30) currentSpeed *= 1.3; // Mniej boost speed
                
                bot.vx = normalizedX * currentSpeed;
                bot.vy = normalizedY * currentSpeed;
            } else {
                bot.vx *= 0.8; // Wiƒôcej hamowanie
                bot.vy *= 0.8;
            }

            bot.x += bot.vx;
            bot.y += bot.vy;

            // Ograniczenia pozycji
            if (bot.canCrossHalf) {
                bot.x = Math.max(canvas.width / 2 - 50, Math.min(canvas.width - bot.radius - 15, bot.x));
            } else {
                bot.x = Math.max(canvas.width / 2 + 10, Math.min(canvas.width - bot.radius - 15, bot.x));
            }
            
            bot.y = Math.max(bot.radius + 15, Math.min(canvas.height - bot.radius - 15, bot.y));
        }

        function updateGoalkeeper(bot) {
            let targetY = ball.y;
            bot.x = Math.max(canvas.width - 50, Math.min(canvas.width - 20, bot.x));
            targetY = Math.max(canvas.height * 0.35, Math.min(canvas.height * 0.65, targetY));
            
            const dy = targetY - bot.y;
            bot.vy = dy * 0.12; // Wolniejsza reakcja bramkarza
            bot.y += bot.vy;
        }

        // Fizyka pi≈Çki
        function updateBall() {
            if (!gameState.ballInPlay || gameState.gameWon) return;

            ball.x += ball.vx;
            ball.y += ball.vy;

            // Rotacja pi≈Çki
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            gameState.ballRotation += speed * 0.05;

            // Odbicia od ≈õcian z efektami
            if (ball.y <= ball.radius + 15 || ball.y >= canvas.height - ball.radius - 15) {
                ball.vy = -ball.vy;
                ball.y = ball.y <= ball.radius + 15 ? ball.radius + 15 : canvas.height - ball.radius - 15;
                createParticles(ball.x, ball.y, '#ffffff', 5);
                gameState.screenShake = 3;
            }

            // Sprawdzenie goli
            if (ball.x <= 15) {
                if (ball.y > canvas.height * 0.35 && ball.y < canvas.height * 0.65) {
                    gameState.botScore++;
                    createGoalEffect(15, canvas.height / 2);
                    updateScore();
                    resetBallAfterGoal();
                } else {
                    ball.vx = -ball.vx;
                    ball.x = ball.radius + 15;
                    createParticles(ball.x, ball.y, '#ff4444', 3);
                    gameState.screenShake = 2;
                }
            }

            if (ball.x >= canvas.width - 15) {
                if (ball.y > canvas.height * 0.35 && ball.y < canvas.height * 0.65) {
                    gameState.playerScore++;
                    createGoalEffect(canvas.width - 15, canvas.height / 2);
                    updateScore();
                    resetBallAfterGoal();
                } else {
                    ball.vx = -ball.vx;
                    ball.x = canvas.width - ball.radius - 15;
                    createParticles(ball.x, ball.y, '#ff4444', 3);
                    gameState.screenShake = 2;
                }
            }

            // Kolizje z graczami
            const allPlayers = [player, ...bots];
            allPlayers.forEach(p => {
                const dx = ball.x - p.x;
                const dy = ball.y - p.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < ball.radius + p.radius) {
                    const nx = dx / distance;
                    const ny = dy / distance;

                    const overlap = ball.radius + p.radius - distance;
                    ball.x += nx * overlap;
                    ball.y += ny * overlap;

                    const dotProduct = ball.vx * nx + ball.vy * ny;
                    
                    createParticles(ball.x, ball.y, p.color, 4);
                    gameState.screenShake = Math.max(gameState.screenShake, 2);
                    
                    if (p !== player) {
                        const goalCenterY = canvas.height / 2;
                        const shootAngle = Math.atan2(goalCenterY - ball.y, 15 - ball.x);
                        
                        const shootPowerX = Math.cos(shootAngle) * (p.shootPower || 1.2) * 8;
                        const shootPowerY = Math.sin(shootAngle) * (p.shootPower || 1.2) * 8;
                        
                        ball.vx = (ball.vx - 2 * dotProduct * nx) * 0.3 + shootPowerX + p.vx * 0.6;
                        ball.vy = (ball.vy - 2 * dotProduct * ny) * 0.3 + shootPowerY + p.vy * 0.6;
                    } else {
                        ball.vx = ball.vx - 2 * dotProduct * nx + p.vx * 0.8;
                        ball.vy = ball.vy - 2 * dotProduct * ny + p.vy * 0.8;
                    }

                    const newSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (newSpeed > ball.maxSpeed) {
                        ball.vx = (ball.vx / newSpeed) * ball.maxSpeed;
                        ball.vy = (ball.vy / newSpeed) * ball.maxSpeed;
                    }
                }
            });

            // Tarcie
            ball.vx *= 0.998;
            ball.vy *= 0.998;

            if (Math.abs(ball.vx) < 0.05 && Math.abs(ball.vy) < 0.05) {
                ball.vx = 0;
                ball.vy = 0;
                gameState.ballInPlay = false;
            }
        }

        function startGame() {
            gameState.gameStarted = true;
            document.getElementById('startMessage').style.display = 'none';
            launchBall();
        }

        function launchBall() {
            gameState.ballInPlay = true;
            const angle = (Math.random() - 0.5) * Math.PI * 0.4;
            const direction = Math.random() < 0.5 ? 1 : -1;
            
            ball.vx = Math.cos(angle) * ball.startSpeed * direction;
            ball.vy = Math.sin(angle) * ball.startSpeed;
        }

        function resetBallAfterGoal() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.vx = 0;
            ball.vy = 0;
            gameState.ballInPlay = false;
        }

        function updateScore() {
            document.getElementById('playerScore').textContent = gameState.playerScore;
            document.getElementById('botScore').textContent = gameState.botScore;

            if (gameState.playerScore >= 5) {
                gameState.gameWon = true;
                gameState.roundWon = true;
                showRoundWinMessage();
            } else if (gameState.botScore >= 5) {
                gameState.gameWon = true;
                gameState.roundWon = false;
                showGameOverMessage();
            }
        }

        function showRoundWinMessage() {
            const currentRoundData = rounds[gameState.currentRound];
            const isLastRound = gameState.currentRound >= rounds.length - 1;
            
            document.getElementById('winnerMessage').innerHTML = `
                <div>üéâ RUNDE ${currentRoundData.number} GEWONNEN! üéâ</div>
                <div style="font-size: 14px; margin: 10px 0; color: #00ffff;">
                    SV BABELSBERG 04 BESIEGT ${currentRoundData.opponentTeam}!
                </div>
                <div style="font-size: 12px; color: #ffff00;">
                    ${isLastRound ? '*** TURNIER GEWONNEN! MEISTER! ***' : 'Bereit f√ºr die n√§chste Runde?'}
                </div>
            `;
            document.getElementById('winnerMessage').style.display = 'block';
            
            if (!isLastRound) {
                document.getElementById('nextRoundBtn').style.display = 'inline-block';
            }
            document.getElementById('retryRoundBtn').style.display = 'none';
        }

        function showGameOverMessage() {
            const currentRoundData = rounds[gameState.currentRound];
            document.getElementById('winnerMessage').innerHTML = `
                <div>üíÄ RUNDE ${currentRoundData.number} VERLOREN! üíÄ</div>
                <div style="font-size: 14px; margin: 10px 0; color: #ff4444;">
                    ${currentRoundData.opponentTeam} GEWINNT!
                </div>
                <div style="font-size: 12px; color: #ffff00;">
                    Runde wiederholen oder neues Turnier?
                </div>
            `;
            document.getElementById('winnerMessage').style.display = 'block';
            document.getElementById('retryRoundBtn').style.display = 'inline-block';
            document.getElementById('nextRoundBtn').style.display = 'none';
        }

        function loadRound() {
            const currentRoundData = rounds[gameState.currentRound];
            
            document.getElementById('roundInfo').textContent = 
                `RUNDE ${currentRoundData.number}: ${currentRoundData.playerTeam} vs ${currentRoundData.opponentTeam}`;
            document.getElementById('playerTeam').textContent = currentRoundData.playerTeam;
            document.getElementById('botTeam').textContent = currentRoundData.opponentTeam;
            document.getElementById('startTitle').textContent = `üöÄ RUNDE ${currentRoundData.number} - DR√úCKEN SIE LEERTASTE! üöÄ`;
            
            // Informacja o ograniczeniach Mariana
            const marianInfo = gameState.currentRound === 0 
                ? "*** MARIAN: NUR EIGENE H√ÑLFTE! ***"
                : "*** MARIAN: GANZES FELD FREI! ***";
            document.getElementById('startSubtitle').textContent = marianInfo;
            
            bots = currentRoundData.bots.map(botData => ({
                ...botData,
                radius: 20,
                vx: 0,
                vy: 0,
                shootPower: botData.shootPower || 1.2,
                reactionSpeed: 0.2,
                startY: botData.y,
                canCrossHalf: botData.canCrossHalf !== undefined ? botData.canCrossHalf : true,
                isGoalkeeper: botData.isGoalkeeper || false
            }));
        }

        function nextRound() {
            gameState.currentRound++;
            resetRound();
            loadRound();
            
            document.getElementById('nextRoundBtn').style.display = 'none';
        }

        function retryRound() {
            resetRound();
            loadRound();
            
            document.getElementById('retryRoundBtn').style.display = 'none';
        }

        function resetRound() {
            gameState.playerScore = 0;
            gameState.botScore = 0;
            gameState.gameWon = false;
            gameState.gameStarted = false;
            gameState.ballInPlay = false;
            gameState.roundWon = false;
            gameState.particles = [];
            gameState.ballRotation = 0;
            gameState.screenShake = 0;
            
            player.x = 100;
            player.y = canvas.height / 2;
            
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.vx = 0;
            ball.vy = 0;
            
            updateScore();
            document.getElementById('winnerMessage').style.display = 'none';
            document.getElementById('startMessage').style.display = 'block';
        }

        function resetGame() {
            gameState.currentRound = 0;
            resetRound();
            loadRound();
            
            document.getElementById('nextRoundBtn').style.display = 'none';
            document.getElementById('retryRoundBtn').style.display = 'none';
        }

        // G≈Ç√≥wna pƒôtla gry
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawField();
            
            if (gameState.gameStarted) {
                updatePlayer();
                updateBots();
                updateBall();
                updateEffects();
            }
            
            drawPlayer(player, 'MARIAN W≈ÅODARSKI', false);
            bots.forEach(bot => {
                drawPlayer(bot, bot.name, true);
            });
            drawBall();
            drawParticles();
            
            requestAnimationFrame(gameLoop);
        }

        // Inicjalizacja gry
        loadRound();
        gameLoop();
    </script>
</body>
</html>

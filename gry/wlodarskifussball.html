<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARIAN W≈ÅODARSKI GESUNDHEIT FUSSBALL 2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(45deg, #0d4a2d, #1a5c36, #0d4a2d);
            font-family: 'Orbitron', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #00ff00;
        }

        h1 {
            color: #ffff00;
            text-shadow: 3px 3px 0px #ff0000, 6px 6px 10px rgba(0,0,0,0.8);
            margin-bottom: 5px;
            font-weight: 900;
            font-size: 24px;
            letter-spacing: 2px;
            text-align: center;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 3px 3px 0px #ff0000, 6px 6px 10px rgba(0,0,0,0.8), 0 0 20px #ffff00; }
            to { text-shadow: 3px 3px 0px #ff0000, 6px 6px 10px rgba(0,0,0,0.8), 0 0 40px #ffff00, 0 0 60px #ffff00; }
        }

        .subtitle {
            color: #00ffff;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            margin-bottom: 10px;
            text-align: center;
        }

        .main-menu {
            background: linear-gradient(45deg, #000033, #000066);
            border: 3px solid #ffff00;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 0 30px rgba(255,255,0,0.5);
        }

        .team-selection {
            background: linear-gradient(45deg, #000033, #000066);
            border: 3px solid #00ff00;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 0 30px rgba(0,255,0,0.5);
            display: none;
        }

        .menu-btn, .team-btn {
            background: linear-gradient(45deg, #ff0000, #ff4444);
            color: #ffff00;
            border: 3px solid #ffff00;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .team-btn {
            background: linear-gradient(45deg, #00aa00, #00ff00);
            color: #000033;
            display: block;
            width: 80%;
            margin: 8px auto;
            font-size: 14px;
        }

        .menu-btn:hover, .team-btn:hover {
            box-shadow: 0 0 15px rgba(255,255,0,0.5);
            transform: scale(1.05);
        }

        .round-info {
            background: linear-gradient(45deg, #000033, #000066);
            border: 3px solid #ff4444;
            padding: 8px 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            text-align: center;
            color: #ffff00;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(255,68,68,0.5);
        }

        .score {
            background: linear-gradient(45deg, #000033, #000066);
            border: 3px solid #00ff00;
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,255,0,0.3);
        }

        .team-name {
            font-size: 12px;
            color: #ffff00;
        }

        .game-container {
            position: relative;
            border: 8px solid #8B4513;
            border-radius: 15px;
            background: #228B22;
            box-shadow: 0 0 30px rgba(0,0,0,0.8), inset 0 0 20px rgba(139,69,19,0.5);
            display: none;
        }

        #gameCanvas {
            display: block;
            border-radius: 8px;
        }

        .controls {
            background: linear-gradient(45deg, #000033, #000066);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
            font-size: 12px;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
            display: none;
        }

        .reset-btn, .next-btn, #retryRoundBtn, .back-btn {
            background: linear-gradient(45deg, #ff0000, #ff4444);
            color: #ffff00;
            border: 3px solid #ffff00;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .next-btn {
            background: linear-gradient(45deg, #00aa00, #00ff00);
            color: #000033;
            border-color: #ffff00;
        }

        .back-btn {
            background: linear-gradient(45deg, #666666, #999999);
            color: #ffffff;
        }

        .reset-btn:hover, .next-btn:hover, #retryRoundBtn:hover, .back-btn:hover {
            box-shadow: 0 0 15px rgba(255,255,0,0.5);
        }

        .winner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #000066, #000099);
            border: 4px solid #ffff00;
            color: #00ff00;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            box-shadow: 0 0 30px rgba(255,255,0,0.5);
        }

        .start-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #000066, #000099);
            border: 4px solid #00ff00;
            color: #ffff00;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            box-shadow: 0 0 30px rgba(0,255,0,0.5);
        }

        .retro-text {
            color: #00ffff;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <h1>üèÜ MARIAN W≈ÅODARSKI GESUNDHEIT FUSSBALL 2 üèÜ</h1>
    <div class="subtitle">*** ZWEITE BUNDESLIGA EDITION 1995 ***</div>
    
    <!-- G≈Å√ìWNE MENU -->
    <div id="mainMenu" class="main-menu">
        <h2 style="color: #ffff00; margin-bottom: 20px;">HAUPTMEN√ú</h2>
        <button class="menu-btn" onclick="startTournament()">üèÜ TURNIER</button>
        <button class="menu-btn" onclick="showTeamSelection()">‚öΩ FREUNDSCHAFTSSPIEL</button>
    </div>

    <!-- WYB√ìR DRU≈ªYNY -->
    <div id="teamSelection" class="team-selection">
        <h2 style="color: #00ff00; margin-bottom: 20px;">GEGNER W√ÑHLEN</h2>
        <button class="team-btn" onclick="startFriendly(0)">üü¶ VFL OLDENBURG (Hans Jurgen)</button>
        <button class="team-btn" onclick="startFriendly(1)">üü£ SV WALDORF MANNHEIM (Klaus Schmidt - GONIO PI≈ÅKƒò!)</button>
        <button class="team-btn" onclick="startFriendly(2)">üü¢ FC HANSA ROSTOCK (Werner + Fritz - GRO√üES FELD!)</button>
        <button class="team-btn" onclick="startFriendly(3)">üü† EINTRACHT BRAUNSCHWEIG (3 Spieler)</button>
        <button class="team-btn" onclick="startFriendly(4)">üî¥ LOKOMOTIV LEIPZIG (4 Spieler + Torwart)</button>
        <button class="team-btn" onclick="startFriendly(5)">üîµ FC CARL ZEISS JENA (3 Kiepscy Spieler - GRO√üES FELD!)</button>
        <button class="team-btn" onclick="startFriendly(6)">üü§ SPVGG UNTERHACHING (2 Gegner + IHR TORWART!)</button>
        <button class="back-btn" onclick="backToMenu()">‚Üê ZUR√úCK</button>
    </div>
    
    <!-- INTERFEJS GRY -->
    <div class="round-info hidden" id="roundInfo">
        RUNDE 1: SV BABELSBERG 04 vs VFL OLDENBURG
    </div>
    
    <div class="score hidden" id="scoreDisplay">
        <div class="team-name" id="playerTeam">SV BABELSBERG 04</div>
        <span id="playerScore">0</span> : <span id="botScore">0</span>
        <div class="team-name" id="botTeam">VFL OLDENBURG</div>
    </div>
    
    <div class="game-container" id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="startMessage" class="start-message">
            <h3 id="startTitle">üöÄ DR√úCKEN SIE LEERTASTE! üöÄ</h3>
            <p class="retro-text">WASD = STEUERUNG</p>
            <p id="startSubtitle">*** SPIEL BEGINNT! ***</p>
        </div>
        <div id="winnerMessage" class="winner" style="display: none;"></div>
    </div>

    <div class="controls" id="gameControls">
        <p class="retro-text"><strong>MARIAN W≈ÅODARSKI:</strong> WASD STEUERUNG | <strong>GEGNER:</strong> COMPUTER KI</p>
        <p>LEERTASTE: START/RESET BALL | ERSTER BIS 5 TORE GEWINNT!</p>
        
        <button class="reset-btn" onclick="backToMenu()">üè† HAUPTMEN√ú</button>
        <button class="next-btn" id="nextRoundBtn" onclick="nextRound()" style="display: none;">‚û°Ô∏è N√ÑCHSTE RUNDE</button>
        <button class="reset-btn" id="retryBtn" onclick="retryMatch()" style="display: none;">üîÑ WIEDERHOLEN</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Stan gry
        let gameMode = null; // 'tournament' or 'friendly'
        let selectedTeam = null;

        // Definicje dru≈ºyn - prƒôdko≈õci zmniejszone o 25%
        const teams = [
            {
                number: 1,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "VFL OLDENBURG",
                field: "grass",
                fieldScale: 1.0,
                bots: [
                    { name: "HANS JURGEN", x: 700, y: 200, color: "#0000ff", maxSpeed: 3.75, aggressiveness: 0.7, canCrossHalf: false, number: 7, role: "defender", preferredY: 200 }
                ]
            },
            {
                number: 2, 
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "SV WALDORF MANNHEIM",
                field: "muddy",
                fieldScale: 1.0,
                bots: [
                    { name: "KLAUS SCHMIDT", x: 700, y: 200, color: "#800080", maxSpeed: 4.5, aggressiveness: 0.8, canCrossHalf: true, number: 9, role: "attacker", preferredY: 200 }
                ]
            },
            {
                number: 3,
                playerTeam: "SV BABELSBERG 04", 
                opponentTeam: "FC HANSA ROSTOCK",
                field: "winter",
                fieldScale: 1.0,
                bots: [
                    { name: "WERNER M√úLLER", x: 650, y: 150, color: "#006600", maxSpeed: 4.5, aggressiveness: 0.8, canCrossHalf: true, number: 8, role: "attacker", preferredY: 150 },
                    { name: "FRITZ WAGNER", x: 650, y: 250, color: "#006600", maxSpeed: 3.75, aggressiveness: 0.7, canCrossHalf: false, number: 11, role: "defender", preferredY: 250 }
                ]
            },
            {
                number: 4,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "EINTRACHT BRAUNSCHWEIG", 
                field: "professional",
                fieldScale: 1.0,
                bots: [
                    { name: "G√úNTER HOFFMAN", x: 600, y: 120, color: "#ff6600", maxSpeed: 5.25, aggressiveness: 0.9, canCrossHalf: true, number: 6, role: "attacker", preferredY: 120 },
                    { name: "DIETER KLEIN", x: 650, y: 200, color: "#ff6600", maxSpeed: 4.5, aggressiveness: 0.8, canCrossHalf: false, number: 4, role: "midfielder", preferredY: 200 },
                    { name: "STEFAN BRAUN", x: 600, y: 280, color: "#ff6600", maxSpeed: 5.25, aggressiveness: 0.9, canCrossHalf: false, number: 3, role: "defender", preferredY: 280 }
                ]
            },
            {
                number: 5,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "LOKOMOTIV LEIPZIG",
                field: "stadium", 
                fieldScale: 1.0,
                bots: [
                    { name: "WOLFGANG RICHTER", x: 600, y: 100, color: "#990000", maxSpeed: 6, aggressiveness: 1.0, canCrossHalf: true, number: 5, role: "attacker", preferredY: 100 },
                    { name: "HERMANN FISCHER", x: 650, y: 200, color: "#990000", maxSpeed: 5.25, aggressiveness: 0.9, canCrossHalf: false, number: 2, role: "midfielder", preferredY: 200 },
                    { name: "RUDOLF BECKER", x: 600, y: 300, color: "#990000", maxSpeed: 6, aggressiveness: 1.0, canCrossHalf: false, number: 1, role: "defender", preferredY: 300 },
                    { name: "OTTO SCHULZ", x: 750, y: 200, color: "#660000", maxSpeed: 2.25, aggressiveness: 0.4, isGoalkeeper: true, canCrossHalf: false, number: 12, role: "goalkeeper", preferredY: 200 }
                ]
            },
            {
                number: 6,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "FC CARL ZEISS JENA",
                field: "sandy",
                fieldScale: 0.75, // Wszystko pomniejszone o 25% = efekt 4x wiƒôkszego boiska
                bots: [
                    { name: "BERND KOCH", x: 650, y: 130, color: "#0066ff", maxSpeed: 3.0, aggressiveness: 0.5, canCrossHalf: false, number: 14, role: "defender", preferredY: 130 },
                    { name: "UWE KRAUSE", x: 680, y: 200, color: "#0066ff", maxSpeed: 2.8, aggressiveness: 0.4, canCrossHalf: false, number: 8, role: "midfielder", preferredY: 200 },
                    { name: "THOMAS WEBER", x: 650, y: 270, color: "#0066ff", maxSpeed: 3.2, aggressiveness: 0.6, canCrossHalf: true, number: 9, role: "attacker", preferredY: 270 }
                ]
            },
            {
                number: 7,
                playerTeam: "SV BABELSBERG 04",
                opponentTeam: "SPVGG UNTERHACHING",
                field: "asphalt",
                fieldScale: 0.75, // Du≈ºe boisko jak Carl Zeiss
                hasPlayerGoalkeeper: true, // W≈Çodarski ma bramkarza!
                bots: [
                    { name: "RALF MULLER", x: 500, y: 200, color: "#800040", maxSpeed: 2.5, aggressiveness: 0.3, canCrossHalf: true, number: 10, role: "attacker", preferredY: 200 },
                    { name: "JOSEF KAHN", x: 750, y: 200, color: "#660033", maxSpeed: 1.8, aggressiveness: 0.2, isGoalkeeper: true, canCrossHalf: false, number: 1, role: "goalkeeper", preferredY: 200 }
                ],
                playerGoalkeeper: { name: "PETER NOWAK", x: 50, y: 200, color: "#cc0000", maxSpeed: 2.0, aggressiveness: 0.3, number: 1, role: "goalkeeper" }
            }
        ];

        // Stan gry z efektami
        let gameState = {
            playerScore: 0,
            botScore: 0,
            gameWon: false,
            gameStarted: false,
            ballInPlay: false,
            currentRound: 0,
            roundWon: false,
            particles: [],
            ballRotation: 0,
            screenShake: 0,
            lastCollisionTime: 0  // Cooldown kolizji
        };

        // Gracz (Marian W≈Çodarski) - szybko≈õƒá 8
        const player = {
            x: 100,
            y: canvas.height / 2,
            radius: 20,
            color: '#ff0000',
            vx: 0,
            vy: 0,
            number: 10
        };

        // Boty - bƒôdƒÖ ≈Çadowane z definicji dru≈ºyn
        let bots = [];
        
        // Bramkarz gracza (opcjonalny)
        let playerGoalkeeper = null;

        // Pi≈Çka - prƒôdko≈õƒá zmniejszona o 15%
        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 8,
            vx: 0,
            vy: 0,
            color: '#ffffff',
            maxSpeed: 11.5,
            startSpeed: 5.7
        };

        // Sterowanie
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                if (!gameState.gameStarted) {
                    startGame();
                } else if (!gameState.ballInPlay && !gameState.gameWon) {
                    launchBall();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Funkcje menu
        function startTournament() {
            gameMode = 'tournament';
            gameState.currentRound = 0;
            showGame();
            loadCurrentTeam();
        }

        function showTeamSelection() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('teamSelection').style.display = 'block';
        }

        function startFriendly(teamIndex) {
            gameMode = 'friendly';
            selectedTeam = teamIndex;
            showGame();
            loadFriendlyTeam(teamIndex);
        }

        function backToMenu() {
            // Ukryj wszystkie ekrany gry
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('gameControls').style.display = 'none';
            document.getElementById('roundInfo').classList.add('hidden');
            document.getElementById('scoreDisplay').classList.add('hidden');
            document.getElementById('teamSelection').style.display = 'none';
            
            // Poka≈º menu g≈Ç√≥wne
            document.getElementById('mainMenu').style.display = 'block';
            
            // Reset stanu gry
            resetGameState();
        }

        function showGame() {
            // Ukryj menu
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('teamSelection').style.display = 'none';
            
            // Poka≈º grƒô
            document.getElementById('gameContainer').style.display = 'block';
            document.getElementById('gameControls').style.display = 'block';
            document.getElementById('roundInfo').classList.remove('hidden');
            document.getElementById('scoreDisplay').classList.remove('hidden');
        }

        function loadCurrentTeam() {
            const currentTeamData = teams[gameState.currentRound];
            loadTeamData(currentTeamData);
            
            if (gameMode === 'tournament') {
                document.getElementById('roundInfo').textContent = 
                    `RUNDE ${currentTeamData.number}: ${currentTeamData.playerTeam} vs ${currentTeamData.opponentTeam}`;
                document.getElementById('startTitle').textContent = `üöÄ RUNDE ${currentTeamData.number} - DR√úCKEN SIE LEERTASTE! üöÄ`;
            }
        }

        function loadFriendlyTeam(teamIndex) {
            const teamData = teams[teamIndex];
            loadTeamData(teamData);
            
            document.getElementById('roundInfo').textContent = 
                `FREUNDSCHAFTSSPIEL: ${teamData.playerTeam} vs ${teamData.opponentTeam}`;
            document.getElementById('startTitle').textContent = `üöÄ FREUNDSCHAFTSSPIEL - DR√úCKEN SIE LEERTASTE! üöÄ`;
        }

        function loadTeamData(teamData) {
            document.getElementById('playerTeam').textContent = teamData.playerTeam;
            document.getElementById('botTeam').textContent = teamData.opponentTeam;
            document.getElementById('startSubtitle').textContent = "*** SPIEL BEGINNT! ***";
            
            bots = teamData.bots.map(botData => ({
                ...botData,
                radius: 20,
                vx: 0,
                vy: 0,
                shootPower: botData.shootPower || 1.2,
                reactionSpeed: 0.2,
                startY: botData.y,
                canCrossHalf: botData.canCrossHalf !== undefined ? botData.canCrossHalf : true,
                isGoalkeeper: botData.isGoalkeeper || false,
                role: botData.role || "midfielder",
                preferredY: botData.preferredY || botData.y
            }));
            
            // ≈Åaduj bramkarza gracza je≈õli istnieje
            if (teamData.hasPlayerGoalkeeper && teamData.playerGoalkeeper) {
                playerGoalkeeper = {
                    ...teamData.playerGoalkeeper,
                    radius: 20,
                    vx: 0,
                    vy: 0,
                    startX: teamData.playerGoalkeeper.x,
                    startY: teamData.playerGoalkeeper.y
                };
            } else {
                playerGoalkeeper = null;
            }
        }

        // Efekty czƒÖsteczkowe
        function createParticles(x, y, color, count) {
            for(let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function createGoalEffect(x, y) {
            for(let i = 0; i < 20; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 60,
                    maxLife: 60,
                    color: '#ffff00',
                    size: Math.random() * 8 + 4
                });
            }
            gameState.screenShake = 8;
        }

        function updateParticles() {
            for(let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if(particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            gameState.particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = `rgba(255,255,0,${alpha})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateEffects() {
            updateParticles();
            if(gameState.screenShake > 0) {
                gameState.screenShake *= 0.9;
                if(gameState.screenShake < 0.1) gameState.screenShake = 0;
            }
        }

        // Funkcje rysowania r√≥≈ºnych boisk
        function drawField() {
            const currentTeamData = gameMode === 'tournament' ? teams[gameState.currentRound] : teams[selectedTeam];
            
            switch(currentTeamData.field) {
                case 'grass':
                    drawGrassField();
                    break;
                case 'muddy':
                    drawMuddyField();
                    break;
                case 'winter':
                    drawWinterField();
                    break;
                case 'professional':
                    drawProfessionalField();
                    break;
                case 'stadium':
                    drawStadiumField();
                    break;
                case 'sandy':
                    drawSandyField();
                    break;
                case 'asphalt':
                    drawAsphaltField();
                    break;
            }
        }

        function drawSandyField() {
            // Piaszczyste boisko z pustynnƒÖ teksturƒÖ
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#F4A460'); // Sandy brown
            gradient.addColorStop(0.5, '#D2B48C'); // Tan
            gradient.addColorStop(1, '#DEB887'); // Burlywood
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Wzory piasku
            ctx.strokeStyle = 'rgba(210, 180, 140, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 15) {
                for (let j = 0; j < canvas.height; j += 15) {
                    ctx.beginPath();
                    ctx.arc(i + Math.sin(i*j*0.01) * 3, j + Math.cos(i*j*0.01) * 3, 1, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Wydmy piasku
            ctx.fillStyle = 'rgba(244, 164, 96, 0.4)';
            [[150,80,60,20], [650,320,80,25], [300,350,50,15], [500,100,70,18]].forEach(([x,y,w,h]) => {
                ctx.beginPath();
                ctx.ellipse(x, y, w, h, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            drawStandardFieldLines();
        }

        function drawAsphaltField() {
            // Asfaltowe boisko z miejskim charakterem
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#404040'); // Ciemny szary
            gradient.addColorStop(0.5, '#333333'); // Grafitowy
            gradient.addColorStop(1, '#1a1a1a'); // Prawie czarny
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Tekstura asfaltu - czƒÖstki
            ctx.fillStyle = 'rgba(80, 80, 80, 0.3)';
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2 + 1;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Pƒôkniƒôcia w asfalcie
            ctx.strokeStyle = 'rgba(20, 20, 20, 0.8)';
            ctx.lineWidth = 2;
            [[100,50,200,80], [600,300,650,350], [300,100,320,200], [500,250,550,280]].forEach(([x1,y1,x2,y2]) => {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            });
            
            // Plamy oleju
            ctx.fillStyle = 'rgba(10, 10, 10, 0.6)';
            [[250,150,15,10], [550,280,20,12], [400,320,18,14]].forEach(([x,y,w,h]) => {
                ctx.beginPath();
                ctx.ellipse(x, y, w, h, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            drawStandardFieldLines();
        }

        function drawGrassField() {
            // Zielone boisko z realistycznymi zniszczeniami
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#32CD32');
            gradient.addColorStop(0.7, '#228B22');
            gradient.addColorStop(1, '#1F7A1F');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Tekstura trawy
            ctx.strokeStyle = 'rgba(50, 205, 50, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            // B≈Çoto pod bramkami
            ctx.fillStyle = 'rgba(139,69,19,0.6)';
            ctx.beginPath();
            ctx.ellipse(60, canvas.height/2, 50, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(canvas.width - 60, canvas.height/2, 50, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Starta murawa
            ctx.fillStyle = 'rgba(101,67,33,0.4)';
            const spots = [{x:300,y:100,w:25,h:15}, {x:500,y:320,w:30,h:20}, {x:150,y:250,w:20,h:25}, {x:650,y:150,w:35,h:18}];
            spots.forEach(spot => {
                ctx.beginPath();
                ctx.ellipse(spot.x, spot.y, spot.w, spot.h, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            drawStandardFieldLines();
        }

        function drawMuddyField() {
            // B≈Çotniste boisko
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(0.5, '#654321');
            gradient.addColorStop(1, '#2F1B0C');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ka≈Çu≈ºe
            ctx.fillStyle = 'rgba(0,100,150,0.7)';
            [[200,100,40,20], [600,300,35,25], [400,150,30,15]].forEach(([x,y,w,h]) => {
                ctx.beginPath();
                ctx.ellipse(x, y, w, h, 0, 0, Math.PI * 2);
                ctx.fill();
            });
            
            drawStandardFieldLines();
        }

        function drawWinterField() {
            // Zimowe boisko
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#f8f8ff');
            gradient.addColorStop(0.7, '#e6f3ff');
            gradient.addColorStop(1, '#d0e8ff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // P≈Çatki ≈õniegu
            const time = Date.now() * 0.001;
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            for(let i = 0; i < 20; i++) {
                const x = (i * 37 + Math.sin(time + i) * 10) % canvas.width;
                const y = (i * 23 + time * 10) % canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 2 + Math.sin(time + i), 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawStandardFieldLines();
        }

        function drawProfessionalField() {
            // Profesjonalne boisko
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, '#228B22');
            gradient.addColorStop(0.5, '#32CD32');
            gradient.addColorStop(1, '#228B22');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Paski
            ctx.fillStyle = 'rgba(50, 205, 50, 0.5)';
            for (let i = 0; i < canvas.width; i += 80) {
                ctx.fillRect(i, 0, 40, canvas.height);
            }
            
            drawStandardFieldLines();
        }

        function drawStadiumField() {
            // Stadionowe boisko fina≈Çowe
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 400);
            gradient.addColorStop(0, '#00FF00');
            gradient.addColorStop(0.7, '#228B22');
            gradient.addColorStop(1, '#006400');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Paski stadionowe
            ctx.fillStyle = 'rgba(34, 139, 34, 0.3)';
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.fillRect(i, 0, 20, canvas.height);
            }
            
            // Reflektory
            const time = Date.now() * 0.001;
            ctx.fillStyle = `rgba(255,255,255,${0.1 + Math.sin(time) * 0.05})`;
            ctx.beginPath();
            ctx.arc(canvas.width/4, 50, 80, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(3*canvas.width/4, 50, 80, 0, Math.PI * 2);
            ctx.fill();
            
            drawStandardFieldLines();
        }

        function drawStandardFieldLines() {
            const currentTeamData = gameMode === 'tournament' ? teams[gameState.currentRound] : teams[selectedTeam];
            const scale = currentTeamData.fieldScale || 1.0;
            
            // Linie boiska - skalowane
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4 * scale;

            // Obramowanie
            ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

            // Linia ≈õrodkowa
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 10);
            ctx.lineTo(canvas.width / 2, canvas.height - 10);
            ctx.stroke();

            // Ko≈Ço ≈õrodkowe - skalowane
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 60 * scale, 0, Math.PI * 2);
            ctx.stroke();

            // Punkt ≈õrodkowy - skalowany
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 4 * scale, 0, Math.PI * 2);
            ctx.fill();

            drawGoalsAndBoxes(scale);
        }

        function drawGoalsAndBoxes(scale = 1.0) {
            // Wyra≈∫niejsze bramki - skalowane
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 10 * scale;
            
            const goalHeight = canvas.height * 0.3 * scale;
            const goalTop = canvas.height * 0.5 - goalHeight/2;
            const goalBottom = canvas.height * 0.5 + goalHeight/2;
            
            // Lewa bramka
            ctx.beginPath();
            ctx.moveTo(10, goalTop);
            ctx.lineTo(10, goalBottom);
            ctx.stroke();
            
            // Prawa bramka
            ctx.beginPath();
            ctx.moveTo(canvas.width - 10, goalTop);
            ctx.lineTo(canvas.width - 10, goalBottom);
            ctx.stroke();
            
            // Pola bramkowe - skalowane
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2 * scale;
            const boxWidth = 40 * scale;
            const boxHeight = canvas.height * 0.2 * scale;
            const boxTop = canvas.height * 0.5 - boxHeight/2;
            
            ctx.strokeRect(10, boxTop, boxWidth, boxHeight);
            ctx.strokeRect(canvas.width - 10 - boxWidth, boxTop, boxWidth, boxHeight);

            // Pola karne - skalowane
            const penaltyWidth = 80 * scale;
            const penaltyHeight = canvas.height * 0.5 * scale;
            const penaltyTop = canvas.height * 0.5 - penaltyHeight/2;
            
            ctx.strokeRect(10, penaltyTop, penaltyWidth, penaltyHeight);
            ctx.strokeRect(canvas.width - 10 - penaltyWidth, penaltyTop, penaltyWidth, penaltyHeight);

            // Punkty karne - skalowane
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(70 * scale, canvas.height / 2, 4 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(canvas.width - 70 * scale, canvas.height / 2, 4 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlayer(playerObj, name, isBot = false) {
            // Pobierz skalƒô dla obecnego boiska
            const currentTeamData = gameMode === 'tournament' ? teams[gameState.currentRound] : teams[selectedTeam];
            const scale = currentTeamData.fieldScale || 1.0;
            
            // Bez shake effect
            const drawX = playerObj.x;
            const drawY = playerObj.y;

            // Skalowany promie≈Ñ gracza
            const scaledRadius = playerObj.radius * scale;

            // Cie≈Ñ gracza
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.arc(drawX + 4, drawY + 4, scaledRadius, 0, Math.PI * 2);
            ctx.fill();

            // Koszulka
            ctx.fillStyle = playerObj.color;
            ctx.beginPath();
            ctx.arc(drawX, drawY, scaledRadius, 0, Math.PI * 2);
            ctx.fill();

            // Paski na koszulce - skalowane
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2 * scale;
            const stripeSpacing = 8 * scale;
            const stripeLength = 15 * scale;
            for(let i = -stripeLength; i <= stripeLength; i += stripeSpacing) {
                ctx.beginPath();
                ctx.moveTo(drawX + i, drawY - stripeLength);
                ctx.lineTo(drawX + i, drawY + stripeLength);
                ctx.stroke();
            }

            // Rƒôce - skalowane
            ctx.fillStyle = '#ffdbac';
            const armDistance = 12 * scale;
            const armRadius = 4 * scale;
            const armHeight = 8 * scale;
            ctx.beginPath();
            ctx.arc(drawX - armDistance, drawY - armHeight, armRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(drawX + armDistance, drawY - armHeight, armRadius, 0, Math.PI * 2);
            ctx.fill();

            // Nogi - skalowane
            ctx.fillStyle = playerObj.color;
            const legDistance = 6 * scale;
            const legRadius = 5 * scale;
            const legHeight = 15 * scale;
            ctx.beginPath();
            ctx.arc(drawX - legDistance, drawY + legHeight, legRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(drawX + legDistance, drawY + legHeight, legRadius, 0, Math.PI * 2);
            ctx.fill();

            // Buty - skalowane
            ctx.fillStyle = '#000000';
            const shoeRadius = 3 * scale;
            const shoeHeight = 18 * scale;
            ctx.beginPath();
            ctx.arc(drawX - legDistance, drawY + shoeHeight, shoeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(drawX + legDistance, drawY + shoeHeight, shoeRadius, 0, Math.PI * 2);
            ctx.fill();

            // G≈Çowa - skalowana
            ctx.fillStyle = '#ffdbac';
            const headRadius = 8 * scale;
            const headHeight = 12 * scale;
            ctx.beginPath();
            ctx.arc(drawX, drawY - headHeight, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // W≈Çosy - skalowane
            ctx.fillStyle = isBot ? '#8B4513' : '#FFD700';
            const hairRadius = 6 * scale;
            const hairHeight = 16 * scale;
            ctx.beginPath();
            ctx.arc(drawX, drawY - hairHeight, hairRadius, 0, Math.PI);
            ctx.fill();

            // Numer na koszulce - skalowany
            ctx.fillStyle = 'white';
            ctx.font = `bold ${14 * scale}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3 * scale;
            const number = playerObj.number.toString();
            ctx.strokeText(number, drawX, drawY + 4 * scale);
            ctx.fillText(number, drawX, drawY + 4 * scale);

            // Nazwa gracza - skalowana
            const nameY = drawY + scaledRadius + 25 * scale;
            const nameWidth = 70 * scale;
            const nameHeight = 12 * scale;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(drawX - nameWidth/2, nameY - nameHeight/2, nameWidth, nameHeight);
            
            ctx.strokeStyle = isBot ? playerObj.color : '#ff0000';
            ctx.lineWidth = 2 * scale;
            ctx.strokeRect(drawX - nameWidth/2, nameY - nameHeight/2, nameWidth, nameHeight);
            
            ctx.fillStyle = 'white';
            ctx.font = `bold ${8 * scale}px Orbitron`;
            ctx.fillText(name, drawX, nameY + 2 * scale);
        }

        function drawBall() {
            // Pobierz skalƒô dla obecnego boiska
            const currentTeamData = gameMode === 'tournament' ? teams[gameState.currentRound] : teams[selectedTeam];
            const scale = currentTeamData.fieldScale || 1.0;
            
            // Bez shake effect
            const drawX = ball.x;
            const drawY = ball.y;

            // Skalowany promie≈Ñ pi≈Çki
            const scaledRadius = ball.radius * scale;

            // ≈ölady za pi≈ÇkƒÖ - skalowane
            if (gameState.ballInPlay && (Math.abs(ball.vx) > 2 || Math.abs(ball.vy) > 2)) {
                for(let i = 1; i <= 3; i++) {
                    const alpha = 0.3 - (i * 0.1);
                    const trailX = drawX - (ball.vx * i * 2);
                    const trailY = drawY - (ball.vy * i * 2);
                    
                    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, (scaledRadius - i) * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Cie≈Ñ pi≈Çki - skalowany
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.arc(drawX + 3, drawY + 3, scaledRadius * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Pi≈Çka
            if (!gameState.ballInPlay && gameState.gameStarted && !gameState.gameWon) {
                if (Math.floor(Date.now() / 200) % 2) {
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                } else {
                    ctx.fillStyle = ball.color;
                }
            } else {
                ctx.fillStyle = ball.color;
            }
            
            ctx.beginPath();
            ctx.arc(drawX, drawY, scaledRadius, 0, Math.PI * 2);
            ctx.fill();

            // Wz√≥r pi≈Çki z rotacjƒÖ - skalowany
            ctx.save();
            ctx.translate(drawX, drawY);
            ctx.rotate(gameState.ballRotation);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1.5 * scale;
            
            // Pentagramy - skalowane
            ctx.beginPath();
            for(let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2 / 5);
                const x = Math.cos(angle) * scaledRadius * 0.6;
                const y = Math.sin(angle) * scaledRadius * 0.6;
                if(i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();

            ctx.restore();

            // Po≈Çysk - skalowany
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.arc(drawX - scaledRadius * 0.3, drawY - scaledRadius * 0.3, scaledRadius * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Sterowanie graczem + natychmiastowa kolizja - prƒôdko≈õƒá zmniejszona o 15%
        function updatePlayer() {
            const speed = 5.1;

            player.vx = 0;
            player.vy = 0;
            
            if (keys['w']) player.vy = -speed;
            if (keys['s']) player.vy = speed;
            if (keys['a']) player.vx = -speed;
            if (keys['d']) player.vx = speed;

            player.x += player.vx;
            player.y += player.vy;

            // NATYCHMIAST po ruchu gracza sprawd≈∫ kolizjƒô z pi≈ÇkƒÖ
            checkPlayerBallCollision();

            // Ograniczenia boiska
            if (gameMode === 'tournament' && gameState.currentRound === 0) {
                player.x = Math.max(player.radius + 15, Math.min(canvas.width / 2 - 10, player.x));
            } else {
                player.x = Math.max(player.radius + 15, Math.min(canvas.width - player.radius - 15, player.x));
            }
            
            player.y = Math.max(player.radius + 15, Math.min(canvas.height - player.radius - 15, player.y));
        }

        function checkPlayerBallCollision() {
            const dx = ball.x - player.x;
            const dy = ball.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = ball.radius + player.radius;

            if (distance < minDistance && distance > 0) {
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Ustaw pi≈Çkƒô dok≈Çadnie na krawƒôdzi gracza
                ball.x = player.x + nx * minDistance;
                ball.y = player.y + ny * minDistance;
                
                // Nadaj pi≈Çce prƒôdko≈õƒá - MINIMUM 7 px/frame (zmniejszone o 15%)
                const kickPower = Math.max(7, Math.sqrt(player.vx * player.vx + player.vy * player.vy) + 4);
                ball.vx = nx * kickPower;
                ball.vy = ny * kickPower;
            }
        }

        // AI Bot√≥w + bramkarz gracza
        function updateBots() {
            bots.forEach(bot => {
                if (!gameState.ballInPlay && !bot.isGoalkeeper) {
                    const readyX = bot.isGoalkeeper ? canvas.width - 40 : canvas.width / 2 + 80;
                    const readyY = bot.isGoalkeeper ? canvas.height / 2 : bot.startY || canvas.height / 2;
                    
                    bot.vx = (readyX - bot.x) * 0.1;
                    bot.vy = (readyY - bot.y) * 0.1;
                    
                    bot.x += bot.vx;
                    bot.y += bot.vy;
                    return;
                }

                if (bot.isGoalkeeper) {
                    updateGoalkeeper(bot);
                } else {
                    updateFieldBot(bot);
                }
            });
            
            // Aktualizuj bramkarza gracza je≈õli istnieje
            if (playerGoalkeeper) {
                updatePlayerGoalkeeper();
            }
        }

        function updatePlayerGoalkeeper() {
            if (!gameState.ballInPlay) {
                // Wr√≥ƒá do pozycji startowej
                playerGoalkeeper.vx = (playerGoalkeeper.startX - playerGoalkeeper.x) * 0.1;
                playerGoalkeeper.vy = (playerGoalkeeper.startY - playerGoalkeeper.y) * 0.1;
            } else {
                // ≈öled≈∫ pi≈Çkƒô ale tylko w bramce
                let targetY = ball.y;
                playerGoalkeeper.x = Math.max(20, Math.min(50, playerGoalkeeper.x));
                targetY = Math.max(canvas.height * 0.35, Math.min(canvas.height * 0.65, targetY));
                
                const dy = targetY - playerGoalkeeper.y;
                playerGoalkeeper.vy = dy * 0.08; // Nieco wolniejszy ni≈º przeciwny bramkarz
            }
            
            playerGoalkeeper.x += playerGoalkeeper.vx;
            playerGoalkeeper.y += playerGoalkeeper.vy;
        }

        function updateFieldBot(bot) {
            const distanceToBall = Math.sqrt((ball.x - bot.x) ** 2 + (ball.y - bot.y) ** 2);
            const ballInReach = distanceToBall < 120;
            
            let targetX, targetY;

            // Sprawd≈∫ odleg≈Ço≈õci do koleg√≥w z dru≈ºyny (unikaj skupiania siƒô)
            const teammateSpacing = 60;
            let spacingAdjustmentX = 0;
            let spacingAdjustmentY = 0;
            
            bots.forEach(teammate => {
                if (teammate !== bot && !teammate.isGoalkeeper) {
                    const dx = bot.x - teammate.x;
                    const dy = bot.y - teammate.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < teammateSpacing && distance > 0) {
                        const pushStrength = (teammateSpacing - distance) / teammateSpacing;
                        spacingAdjustmentX += (dx / distance) * pushStrength * 30;
                        spacingAdjustmentY += (dy / distance) * pushStrength * 30;
                    }
                }
            });

            // R√≥≈ºne zachowania w zale≈ºno≈õci od roli
            switch(bot.role) {
                case "attacker":
                    if (ballInReach || ball.x > canvas.width * 0.3) {
                        // Napastnicy agresywnie goniƒÖ pi≈Çkƒô
                        const predictTime = 6;
                        targetX = ball.x + ball.vx * predictTime;
                        targetY = ball.y + ball.vy * predictTime;
                        
                        if (distanceToBall < 50) {
                            // Pozycjonuj siƒô za pi≈ÇkƒÖ do strza≈Çu
                            const goalCenterY = canvas.height / 2;
                            const angleToGoal = Math.atan2(goalCenterY - ball.y, 20 - ball.x);
                            targetX = ball.x + Math.cos(angleToGoal + Math.PI) * 30;
                            targetY = ball.y + Math.sin(angleToGoal + Math.PI) * 30;
                        }
                    } else {
                        // Czekaj w pozycji ofensywnej
                        targetX = canvas.width * 0.6;
                        targetY = bot.preferredY;
                    }
                    break;
                    
                case "midfielder":
                    if (ballInReach) {
                        // Pomocnicy wspierajƒÖ grƒô
                        targetX = ball.x + (Math.random() - 0.5) * 40;
                        targetY = ball.y + (Math.random() - 0.5) * 40;
                    } else {
                        // Trzymaj pozycjƒô centralnƒÖ
                        targetX = canvas.width * 0.65;
                        targetY = bot.preferredY + (ball.y - canvas.height/2) * 0.3;
                    }
                    break;
                    
                case "defender":
                default:
                    if (ball.x > canvas.width * 0.6 && ballInReach) {
                        // Obro≈Ñcy reagujƒÖ tylko gdy pi≈Çka blisko
                        targetX = ball.x + 20;
                        targetY = ball.y;
                    } else {
                        // Trzymaj pozycjƒô defensywnƒÖ
                        targetX = canvas.width * 0.75;
                        targetY = bot.preferredY + (ball.y - canvas.height/2) * 0.2;
                    }
                    break;
            }

            // Zastosuj korektƒô rozstawienia
            targetX += spacingAdjustmentX;
            targetY += spacingAdjustmentY;

            // System b≈Çƒôd√≥w dla r√≥≈ºnych przeciwnik√≥w
            let errorChance;
            if (gameMode === 'tournament') {
                switch(gameState.currentRound) {
                    case 0: errorChance = 0.15; break;
                    case 1: errorChance = 0.10; break;
                    case 2: errorChance = 0.08; break;
                    case 3: errorChance = 0.06; break;
                    case 4: errorChance = 0.04; break;
                    default: errorChance = 0.08;
                }
            } else {
                switch(selectedTeam) {
                    case 0: errorChance = 0.15; break; // VFL Oldenburg
                    case 1: errorChance = 0.10; break; // SV Waldorf Mannheim  
                    case 2: errorChance = 0.12; break; // FC Hansa Rostock - zwiƒôkszone b≈Çƒôdy
                    case 3: errorChance = 0.06; break; // Eintracht Braunschweig
                    case 4: errorChance = 0.04; break; // Lokomotiv Leipzig
                    case 5: errorChance = 0.20; break; // FC Carl Zeiss Jena
                    case 6: errorChance = 0.18; break; // SpVgg Unterhaching
                    default: errorChance = 0.08;
                }
            }
            
            // Dodaj b≈Çƒôdy w zale≈ºno≈õci od roli
            let roleErrorMultiplier = 1.0;
            switch(bot.role) {
                case "attacker": roleErrorMultiplier = 0.8; break;  // Napastnicy bardziej precyzyjni
                case "midfielder": roleErrorMultiplier = 1.0; break;
                case "defender": roleErrorMultiplier = 1.2; break;  // Obro≈Ñcy mniej zwinni
            }
            
            if (Math.random() < errorChance * roleErrorMultiplier) {
                targetX += (Math.random() - 0.5) * 60;
                targetY += (Math.random() - 0.5) * 60;
            }

            const dx = targetX - bot.x;
            const dy = targetY - bot.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 3) {
                const normalizedX = dx / distance;
                const normalizedY = dy / distance;
                
                // Sta≈Ça prƒôdko≈õƒá - brak bonus√≥w
                const currentSpeed = bot.maxSpeed;
                
                bot.vx = normalizedX * currentSpeed;
                bot.vy = normalizedY * currentSpeed;
            } else {
                bot.vx *= 0.8;
                bot.vy *= 0.8;
            }

            bot.x += bot.vx;
            bot.y += bot.vy;

            // Ograniczenia pozycji
            if (bot.canCrossHalf) {
                bot.x = Math.max(canvas.width / 2 - 50, Math.min(canvas.width - bot.radius - 15, bot.x));
            } else {
                bot.x = Math.max(canvas.width / 2 + 10, Math.min(canvas.width - bot.radius - 15, bot.x));
            }
            
            bot.y = Math.max(bot.radius + 15, Math.min(canvas.height - bot.radius - 15, bot.y));
        }

        function updateGoalkeeper(bot) {
            let targetY = ball.y;
            bot.x = Math.max(canvas.width - 50, Math.min(canvas.width - 20, bot.x));
            targetY = Math.max(canvas.height * 0.35, Math.min(canvas.height * 0.65, targetY));
            
            const dy = targetY - bot.y;
            bot.vy = dy * 0.12;
            bot.y += bot.vy;
        }

        // Fizyka pi≈Çki
        function updateBall() {
            if (!gameState.ballInPlay || gameState.gameWon) return;

            ball.x += ball.vx;
            ball.y += ball.vy;

            // Rotacja pi≈Çki
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            gameState.ballRotation += speed * 0.05;

            // Odbicia od ≈õcian - bez efekt√≥w
            if (ball.y <= ball.radius + 15 || ball.y >= canvas.height - ball.radius - 15) {
                ball.vy = -ball.vy;
                ball.y = ball.y <= ball.radius + 15 ? ball.radius + 15 : canvas.height - ball.radius - 15;
            }

            // Sprawdzenie goli z bramkarzem gracza
            if (ball.x <= 15) {
                if (ball.y > canvas.height * 0.35 && ball.y < canvas.height * 0.65) {
                    // Sprawd≈∫ czy bramkarz gracza nie zablokowa≈Ç
                    let goalBlocked = false;
                    if (playerGoalkeeper) {
                        const distanceToGoalkeeper = Math.sqrt((ball.x - playerGoalkeeper.x) ** 2 + (ball.y - playerGoalkeeper.y) ** 2);
                        if (distanceToGoalkeeper < ball.radius + playerGoalkeeper.radius) {
                            goalBlocked = true;
                            // Bramkarz odbija pi≈Çkƒô
                            ball.vx = Math.abs(ball.vx) * 1.2; // Odbicie w przeciwnƒÖ stronƒô
                            ball.vy += (Math.random() - 0.5) * 4;
                        }
                    }
                    
                    if (!goalBlocked) {
                        gameState.botScore++;
                        updateScore();
                        resetBallAfterGoal();
                    }
                } else {
                    ball.vx = -ball.vx;
                    ball.x = ball.radius + 15;
                }
            }

            if (ball.x >= canvas.width - 15) {
                if (ball.y > canvas.height * 0.35 && ball.y < canvas.height * 0.65) {
                    gameState.playerScore++;
                    updateScore();
                    resetBallAfterGoal();
                } else {
                    ball.vx = -ball.vx;
                    ball.x = canvas.width - ball.radius - 15;
                }
            }

            // Kolizje z graczami - ulepszona wersja anty-chaos
            const currentTime = Date.now();
            const allPlayers = [player, ...bots];
            if (playerGoalkeeper) {
                allPlayers.push(playerGoalkeeper);
            }
            allPlayers.forEach(p => {
                const dx = ball.x - p.x;
                const dy = ball.y - p.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < ball.radius + p.radius) {
                    // D≈Çu≈ºszy cooldown kolizji - zapobiega wielokrotnym kolizjom
                    if (currentTime - gameState.lastCollisionTime < 300) {
                        return; // Pomi≈Ñ kolizjƒô je≈õli za wcze≈õnie (zwiƒôkszone z 150ms)
                    }
                    
                    const nx = dx / distance;
                    const ny = dy / distance;

                    // Znacznie wiƒôksze rozdzielenie obiekt√≥w
                    const overlap = ball.radius + p.radius - distance;
                    const separationDistance = overlap + 8; // Zwiƒôkszone z 2 do 8 pikseli bufora
                    ball.x += nx * separationDistance;
                    ball.y += ny * separationDistance;

                    // Sprawd≈∫ czy pi≈Çka by≈Ça praktycznie nieruchoma
                    const ballSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    const wasStationary = ballSpeed < 1;

                    const dotProduct = ball.vx * nx + ball.vy * ny;
                    
                    createParticles(ball.x, ball.y, p.color, 4);
                    gameState.screenShake = Math.max(gameState.screenShake, 2);
                    
                    if (p !== player) {
                        const goalCenterY = canvas.height / 2;
                        const shootAngle = Math.atan2(goalCenterY - ball.y, 15 - ball.x);
                        
                        const shootPowerX = Math.cos(shootAngle) * (p.shootPower || 1.2) * 6;
                        const shootPowerY = Math.sin(shootAngle) * (p.shootPower || 1.2) * 6;
                        
                        ball.vx = (ball.vx - 2 * dotProduct * nx) * 0.3 + shootPowerX + p.vx * 0.2; // Zmniejszone z 0.4
                        ball.vy = (ball.vy - 2 * dotProduct * ny) * 0.3 + shootPowerY + p.vy * 0.2;
                    } else {
                        // Dla gracza - specjalne zachowanie w zale≈ºno≈õci od stanu pi≈Çki + odrzut
                        if (wasStationary) {
                            // Pi≈Çka by≈Ça nieruchoma - mocne kopniƒôcie w kierunku ruchu gracza
                            const playerSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                            if (playerSpeed > 0) {
                                const kickPower = 8; // Sta≈Ça si≈Ça kopniƒôcia
                                ball.vx = (p.vx / playerSpeed) * kickPower;
                                ball.vy = (p.vy / playerSpeed) * kickPower;
                            } else {
                                // Gracz stoi - delikatne odbicie
                                ball.vx = nx * 3;
                                ball.vy = ny * 3;
                            }
                        } else {
                            // Pi≈Çka siƒô toczy≈Ça - normalne odbicie z minimalnym wp≈Çywem gracza
                            ball.vx = ball.vx - 2 * dotProduct * nx + p.vx * 0.1; // Bardzo ma≈Çy wp≈Çyw
                            ball.vy = ball.vy - 2 * dotProduct * ny + p.vy * 0.1;
                        }
                        
                        // KLUCZOWE: Odepchnij gracza od pi≈Çki
                        if (p === player) {
                            const pushPower = 3;
                            player.pushbackX = -nx * pushPower;  // Przeciwny kierunek do pi≈Çki
                            player.pushbackY = -ny * pushPower;
                            player.stunned = 8;  // 8 klatek ograniczonej responsywno≈õci
                        }
                    }

                    // Zapewnij minimalnƒÖ prƒôdko≈õƒá pi≈Çki po kolizji (unikaj "przyklejania")
                    const newSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (newSpeed < 2) {
                        // Je≈õli pi≈Çka za wolna, nadaj jej minimalnƒÖ prƒôdko≈õƒá
                        ball.vx = nx * 2;
                        ball.vy = ny * 2;
                    } else if (newSpeed > ball.maxSpeed) {
                        ball.vx = (ball.vx / newSpeed) * ball.maxSpeed;
                        ball.vy = (ball.vy / newSpeed) * ball.maxSpeed;
                    }
                    
                    // Ustaw cooldown
                    gameState.lastCollisionTime = currentTime;
                }
            });

            // Tarcie
            ball.vx *= 0.998;
            ball.vy *= 0.998;

            if (Math.abs(ball.vx) < 0.05 && Math.abs(ball.vy) < 0.05) {
                ball.vx = 0;
                ball.vy = 0;
                gameState.ballInPlay = false;
            }
        }

        function startGame() {
            gameState.gameStarted = true;
            document.getElementById('startMessage').style.display = 'none';
            launchBall();
        }

        function launchBall() {
            gameState.ballInPlay = true;
            const angle = (Math.random() - 0.5) * Math.PI * 0.4;
            const direction = Math.random() < 0.5 ? 1 : -1;
            
            ball.vx = Math.cos(angle) * ball.startSpeed * direction;
            ball.vy = Math.sin(angle) * ball.startSpeed;
        }

        function resetBallAfterGoal() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.vx = 0;
            ball.vy = 0;
            gameState.ballInPlay = false;
        }

        function updateScore() {
            document.getElementById('playerScore').textContent = gameState.playerScore;
            document.getElementById('botScore').textContent = gameState.botScore;

            if (gameState.playerScore >= 5) {
                gameState.gameWon = true;
                gameState.roundWon = true;
                showWinMessage();
            } else if (gameState.botScore >= 5) {
                gameState.gameWon = true;
                gameState.roundWon = false;
                showLoseMessage();
            }
        }

        function showWinMessage() {
            const currentTeamData = gameMode === 'tournament' ? teams[gameState.currentRound] : teams[selectedTeam];
            
            if (gameMode === 'tournament') {
                const isLastRound = gameState.currentRound >= teams.length - 1;
                
                document.getElementById('winnerMessage').innerHTML = `
                    <div>üéâ RUNDE ${currentTeamData.number} GEWONNEN! üéâ</div>
                    <div style="font-size: 14px; margin: 10px 0; color: #00ffff;">
                        SV BABELSBERG 04 BESIEGT ${currentTeamData.opponentTeam}!
                    </div>
                    <div style="font-size: 12px; color: #ffff00;">
                        ${isLastRound ? '*** TURNIER GEWONNEN! MEISTER! ***' : 'Bereit f√ºr die n√§chste Runde?'}
                    </div>
                `;
                
                if (!isLastRound) {
                    document.getElementById('nextRoundBtn').style.display = 'inline-block';
                }
            } else {
                document.getElementById('winnerMessage').innerHTML = `
                    <div>üéâ FREUNDSCHAFTSSPIEL GEWONNEN! üéâ</div>
                    <div style="font-size: 14px; margin: 10px 0; color: #00ffff;">
                        SV BABELSBERG 04 BESIEGT ${currentTeamData.opponentTeam}!
                    </div>
                    <div style="font-size: 12px; color: #ffff00;">
                        Gut gespielt!
                    </div>
                `;
            }
            
            document.getElementById('winnerMessage').style.display = 'block';
            document.getElementById('retryBtn').style.display = 'inline-block';
        }

        function showLoseMessage() {
            const currentTeamData = gameMode === 'tournament' ? teams[gameState.currentRound] : teams[selectedTeam];
            
            if (gameMode === 'tournament') {
                document.getElementById('winnerMessage').innerHTML = `
                    <div>üíÄ RUNDE ${currentTeamData.number} VERLOREN! üíÄ</div>
                    <div style="font-size: 14px; margin: 10px 0; color: #ff4444;">
                        ${currentTeamData.opponentTeam} GEWINNT!
                    </div>
                    <div style="font-size: 12px; color: #ffff00;">
                        Runde wiederholen?
                    </div>
                `;
            } else {
                document.getElementById('winnerMessage').innerHTML = `
                    <div>üíÄ FREUNDSCHAFTSSPIEL VERLOREN! üíÄ</div>
                    <div style="font-size: 14px; margin: 10px 0; color: #ff4444;">
                        ${currentTeamData.opponentTeam} GEWINNT!
                    </div>
                    <div style="font-size: 12px; color: #ffff00;">
                        Nochmal versuchen?
                    </div>
                `;
            }
            
            document.getElementById('winnerMessage').style.display = 'block';
            document.getElementById('retryBtn').style.display = 'inline-block';
            document.getElementById('nextRoundBtn').style.display = 'none';
        }

        function nextRound() {
            if (gameMode === 'tournament') {
                gameState.currentRound++;
                resetMatch();
                loadCurrentTeam();
                
                document.getElementById('nextRoundBtn').style.display = 'none';
            }
        }

        function retryMatch() {
            resetMatch();
            
            if (gameMode === 'tournament') {
                loadCurrentTeam();
            } else {
                loadFriendlyTeam(selectedTeam);
            }
            
            document.getElementById('retryBtn').style.display = 'none';
            document.getElementById('nextRoundBtn').style.display = 'none';
        }

        function resetMatch() {
            gameState.playerScore = 0;
            gameState.botScore = 0;
            gameState.gameWon = false;
            gameState.gameStarted = false;
            gameState.ballInPlay = false;
            gameState.roundWon = false;
            gameState.particles = [];
            gameState.ballRotation = 0;
            gameState.screenShake = 0;
            gameState.lastCollisionTime = 0; // Reset cooldown
            
            player.x = 100;
            player.y = canvas.height / 2;
            player.stunned = 0;      // Reset og≈Çuszenia
            player.pushbackX = 0;    // Reset odrzutu
            player.pushbackY = 0;
            
            // Reset bramkarza gracza je≈õli istnieje
            if (playerGoalkeeper) {
                playerGoalkeeper.x = playerGoalkeeper.startX;
                playerGoalkeeper.y = playerGoalkeeper.startY;
                playerGoalkeeper.vx = 0;
                playerGoalkeeper.vy = 0;
            }
            
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.vx = 0;
            ball.vy = 0;
            
            updateScore();
            document.getElementById('winnerMessage').style.display = 'none';
            document.getElementById('startMessage').style.display = 'block';
        }

        function resetGameState() {
            gameMode = null;
            selectedTeam = null;
            gameState.currentRound = 0;
            resetMatch();
        }

        // G≈Ç√≥wna pƒôtla gry
        function gameLoop() {
            if (gameMode) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                drawField();
                
                if (gameState.gameStarted) {
                    updatePlayer();
                    updateBots();
                    updateBall();
                }
                
                drawPlayer(player, 'MARIAN W≈ÅODARSKI', false);
                if (playerGoalkeeper) {
                    drawPlayer(playerGoalkeeper, playerGoalkeeper.name, false);
                }
                bots.forEach(bot => {
                    drawPlayer(bot, bot.name, true);
                });
                drawBall();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Inicjalizacja
        gameLoop();
    </script>
</body>
</html>

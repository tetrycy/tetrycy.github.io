<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>OUTPOST '95: SUPREME COMMANDER [TACTICAL]</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root { --f-green: #20ff20; --f-bg: #050805; --panel: #1a1c1a; --f-red: #ff1111; --f-blue: #00ffff; --f-purple: #ff00ff; --f-hp: #ffff00; }
        body { margin: 0; background: #000; color: var(--f-green); font-family: VT323, monospace; display: flex; height: 100vh; overflow: hidden; font-size: 18px; user-select: none; }
        #viewport { flex-grow: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; padding: 20px; min-height: 0; }
        canvas { border: 2px solid var(--f-green); background: var(--f-bg); cursor: crosshair; image-rendering: pixelated; max-width: 100%; max-height: 100%; width: auto; height: auto; object-fit: contain; box-shadow: 0 0 20px rgba(32, 255, 32, 0.1); }
        #sidebar { width: 380px; background: var(--panel); border-left: 4px ridge #444; display: flex; flex-direction: column; padding: 20px; z-index: 10; }
        .screen { background: #000; border: 1px solid var(--f-green); padding: 15px; margin-bottom: 12px; box-shadow: inset 0 0 15px rgba(0,255,0,0.2); }
        .btn { background: #222; color: var(--f-green); border: 2px solid var(--f-green); padding: 12px; margin: 5px 0; cursor: pointer; font-family: VT323; font-size: 1.3em; text-transform: uppercase; width: 100%; text-align: left; }
        .btn:hover:not(:disabled) { background: var(--f-green); color: #000; }
        .btn.active { background: #083308; box-shadow: 0 0 10px var(--f-green); }
        .stat { display: flex; justify-content: space-between; font-size: 1.5em; margin: 5px 0; }
        #terminal { font-size: 1em; height: 160px; overflow-y: auto; color: #8f8; border: 1px solid #1a331a; padding: 8px; background: #020502; line-height: 1.3; }
        h2 { font-size: 1.8em; margin: 0 0 15px 0; }
    </style>
</head>
<body>

<div id="viewport">
    <canvas id="gameCanvas" width="1200" height="900"></canvas>
</div>

<div id="sidebar">
    <h2 style="text-align:center; border-bottom:2px solid var(--f-green); margin:0 0 10px 0;">STRAT-COM INTERFACE</h2>
    <div class="screen">
        <div class="stat"><span>CREDITS:</span> <span id="ui-money">$800</span></div>
        <div class="stat"><span>HQ HULL:</span> <span id="ui-hp">100%</span></div>
    </div>
    <div class="screen" id="terminal">> AWAITING MISSION...</div>
    <div id="buildMenu" style="flex-grow: 1; overflow-y: auto;"></div>
    <button class="btn" id="actionBtn" style="background:#400; border-color:#f44; color:#f44; font-weight:bold; text-align:center;" onclick="handleAction()">EXECUTE COMBAT</button>
</div>

<script>
const CONFIG = {
    WIDTH: 1200, HEIGHT: 900, SCALE: 0.5, BASE_OFF: { x: 300, y: 150 }, CELL: 50, GRID: 12,
    PATH_GRID: 40, // Gęstość siatki nawigacyjnej
    DEFENSE: {
        CORE: { name: "HQ BUNKER", cost: 0, hp: 6000, type: 'core', color: '#0ff', size: 25 },
        WALL: { name: "HEAVY WALL", cost: 20, hp: 1500, type: 'wall', color: '#666', size: 18 },
        SENTRY: { name: "AUTO-TURRET", cost: 180, range: 250, dmg: 15, rof: 500, hp: 500, type: 'tower', color: '#ff0', size: 15 },
        BATTERY: { name: "LR BATTERY", cost: 400, range: 420, dmg: 200, rof: 2800, hp: 800, type: 'tower', color: '#f80', size: 18 }
    },
    BUILDINGS: {
        SOLAR: { name: "SOLAR ARRAY", cost: 150, pwr: 50, color: "#AA0" },
        FARM: { name: "BIO-FARM", cost: 200, pwr: -10, color: "#0A0" },
        MUNITION: { name: "MUNITION FAB", cost: 450, pwr: -50, color: "#A00" }
    }
};

let game = {
    money: 800, hp: 6000, wave: 0, mode: 'BASE',
    buildings: [], entities: [], enemies: [], projectiles: [],
    terrain: { hills: [], lakes: [], forests: [] },
    flowField: [], // Mapa wektorów ruchu dla AI
    selected: null, corePlaced: false,
    mouse: { x:0, y:0, down: false }, keys: {},
    player: { x: 600, y: 450, hp: 600, maxHp: 600, spd: 4.0 },
    spawnDir: 'NORTH'
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- AI: GENEROWANIE POLA PRZEPŁYWU (Pathfinding) ---
function generateFlowField() {
    const cols = Math.ceil(CONFIG.WIDTH / CONFIG.PATH_GRID);
    const rows = Math.ceil(CONFIG.HEIGHT / CONFIG.PATH_GRID);
    const core = game.entities.find(e => e.type === 'core');
    if (!core) return;

    const costField = new Array(cols).fill(0).map(() => new Array(rows).fill(9999));
    const targetX = Math.floor(core.x / CONFIG.PATH_GRID);
    const targetY = Math.floor(core.y / CONFIG.PATH_GRID);

    // Dijkstra do liczenia kosztów dojścia
    let q = [{x: targetX, y: targetY, c: 0}];
    costField[targetX][targetY] = 0;

    while(q.length > 0) {
        let curr = q.shift();
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
            let nx = curr.x + d[0], ny = curr.y + d[1];
            if(nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                let wx = nx * CONFIG.PATH_GRID;
                let wy = ny * CONFIG.PATH_GRID;
                
                // CZYTANIE TERENU PRZEZ AI
                let tileCost = 1;
                if (game.terrain.lakes.some(l => isPointInPolygon(wx, wy, l.points))) tileCost = 50; // Jezioro to przeszkoda
                if (game.terrain.hills.some(h => !h.isRidge && Math.hypot(wx-h.x, wy-h.y) < 60)) tileCost = 15; // Góra spowalnia

                let total = curr.c + tileCost;
                if (total < costField[nx][ny]) {
                    costField[nx][ny] = total;
                    q.push({x: nx, y: ny, c: total});
                }
            }
        });
    }

    // Tworzenie wektorów kierunkowych
    game.flowField = new Array(cols).fill(0).map((_, x) => new Array(rows).fill(0).map((_, y) => {
        let min = costField[x][y];
        let vec = {x: 0, y: 0};
        [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d => {
            let nx = x + d[0], ny = y + d[1];
            if(nx >= 0 && nx < cols && ny >= 0 && ny < rows && costField[nx][ny] < min) {
                min = costField[nx][ny];
                vec = {x: d[0], y: d[1]};
            }
        });
        return vec;
    }));
}

// --- RENDERER KSZTAŁTÓW Z WYPEŁNIENIEM HP ---
function drawUnit(x, y, verts, color, hpRatio, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    verts.forEach((v, i) => {
        let vx = Math.cos(v.a) * v.d;
        let vy = Math.sin(v.a) * v.d;
        if(i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
    });
    ctx.closePath();
    
    // Obrys
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Wypełnienie "cieczą" HP
    ctx.clip();
    ctx.fillStyle = color;
    let fillY = size * 2 - (hpRatio * size * 4);
    ctx.fillRect(-size * 2, fillY, size * 4, size * 4);
    ctx.restore();
}

function handleAction() {
    if (game.mode === 'BASE') {
        game.mode = 'PREP'; game.wave++; game.entities = []; game.corePlaced = false;
        generateStrategicMap(); spawnWaveLogic(); updateBuildMenu();
        document.getElementById('actionBtn').innerText = "LOCK HQ AND DEPLOY";
    } else if (game.mode === 'PREP') {
        if (!game.corePlaced) { logTerminal("CRITICAL: HQ MUST BE DEPLOYED."); return; }
        generateFlowField(); // Oblicz ścieżki dla tej mapy
        game.mode = 'COMBAT';
        document.getElementById('actionBtn').innerText = "IN COMBAT";
        document.getElementById('actionBtn').disabled = true;
    }
}

function generateComplexShape(size) {
    const vertices = [];
    const pts = 3 + Math.floor(Math.random() * 10);
    for(let i = 0; i < pts; i++) {
        const angle = (i / pts) * Math.PI * 2;
        vertices.push({ a: angle, d: size * (0.6 + Math.random() * 0.7) });
    }
    return vertices;
}

function createEnemy(hp, moveType) {
    let x, y, off = 100;
    if(game.spawnDir === 'NORTH') { x = Math.random()*CONFIG.WIDTH; y = -off; }
    else if(game.spawnDir === 'SOUTH') { x = Math.random()*CONFIG.WIDTH; y = CONFIG.HEIGHT+off; }
    else if(game.spawnDir === 'EAST') { x = CONFIG.WIDTH+off; y = Math.random()*CONFIG.HEIGHT; }
    else { x = -off; y = Math.random()*CONFIG.HEIGHT; }

    const size = 10 + (hp * 0.03);
    const color = moveType === 'LAND' ? '#ff3333' : (moveType === 'SWIM' ? '#00ffff' : '#ff33ff');
    return { 
        x, y, hp, maxHp: hp, moveType, size, color, 
        verts: generateComplexShape(size),
        speed: moveType==='FLY' ? 1.5 : 1.0 
    };
}

function updateCombat() {
    let pFactor = 1.0;
    // Gracz reaguje na teren
    if (game.terrain.lakes.some(l => isPointInPolygon(game.player.x, game.player.y, l.points))) pFactor = 0.3;
    
    if (game.keys['KeyW']) game.player.y -= game.player.spd * pFactor;
    if (game.keys['KeyS']) game.player.y += game.player.spd * pFactor;
    if (game.keys['KeyA']) game.player.x -= game.player.spd * pFactor;
    if (game.keys['KeyD']) game.player.x += game.player.spd * pFactor;

    if (game.mouse.down) playerShoot();

    const core = game.entities.find(e => e.type === 'core');
    game.enemies.forEach((e, i) => {
        let vx = 0, vy = 0;

        if (e.moveType === 'FLY') {
            let a = Math.atan2(core.y - e.y, core.x - e.x);
            vx = Math.cos(a); vy = Math.sin(a);
        } else {
            // Ruch po Flow Field (AI)
            let gx = Math.floor(e.x / CONFIG.PATH_GRID);
            let gy = Math.floor(e.y / CONFIG.PATH_GRID);
            if (game.flowField[gx] && game.flowField[gx][gy]) {
                vx = game.flowField[gx][gy].x; vy = game.flowField[gx][gy].y;
            }
        }

        let speedMult = 1.0;
        if (e.moveType === 'SWIM' && game.terrain.lakes.some(l => isPointInPolygon(e.x, e.y, l.points))) speedMult = 2.0;

        e.x += vx * e.speed * speedMult;
        e.y += vy * e.speed * speedMult;

        // Kolizje Kamikaze
        game.entities.forEach(ent => {
            if (Math.hypot(e.x - ent.x, e.y - ent.y) < e.size + ent.size) {
                ent.curHP -= e.hp; e.hp = 0;
                if (ent.type === 'core') game.hp = Math.max(0, ent.curHP);
            }
        });
    });

    // Wieżyczki
    game.entities.forEach(u => {
        if (u.type === 'tower' && Date.now() - u.lastFire > u.rof) {
            const target = game.enemies.find(e => Math.hypot(e.x - u.x, e.y - u.y) < u.range);
            if (target) {
                target.hp -= u.dmg; u.lastFire = Date.now();
                ctx.strokeStyle = "#ff0"; ctx.beginPath(); ctx.moveTo(u.x, u.y); ctx.lineTo(target.x, target.y); ctx.stroke();
            }
        }
    });

    game.enemies = game.enemies.filter(e => e.hp > 0);
    game.entities = game.entities.filter(e => e.curHP > 0);
    if (game.enemies.length === 0) { game.mode = 'BASE'; document.getElementById('actionBtn').disabled = false; }
    if (game.hp <= 0) location.reload();
}

// --- TWOJE ORYGINALNE RYSOWANIE TERENU (BEZ ZMIAN) ---
function renderTacticalMap() {
    ctx.fillStyle = "#000"; ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
    game.terrain.lakes.forEach(lake => {
        ctx.fillStyle = "rgba(150, 180, 50, 0.4)"; ctx.beginPath();
        lake.points.forEach((p, i) => (i === 0) ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
        ctx.closePath(); ctx.fill(); ctx.strokeStyle = "#9a0"; ctx.lineWidth = 2; ctx.stroke();
    });
    game.terrain.hills.forEach(h => {
        const elevation = h.level / h.totalLayers;
        ctx.strokeStyle = `rgb(${20+elevation*180}, ${30+elevation*150}, ${10+elevation*100})`;
        ctx.lineWidth = h.level % 5 === 0 ? 2.5 : 1;
        ctx.beginPath();
        if(h.isRidge) h.points.forEach((p, i) => (i === 0) ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
        else h.layers[0].verts.forEach((v, i) => (i === 0) ? ctx.moveTo(h.x+v.x, h.y+v.y) : ctx.lineTo(h.x+v.x, h.y+v.y));
        if(!h.isRidge) ctx.closePath();
        ctx.stroke();
    });
}

function renderAnomalies() {
    game.enemies.forEach(e => drawUnit(e.x, e.y, e.verts, e.color, e.hp/e.maxHp, e.size));
}

function renderEntities() {
    game.entities.forEach(e => {
        let v = [{a:0.78,d:e.size*1.4},{a:2.35,d:e.size*1.4},{a:3.92,d:e.size*1.4},{a:5.49,d:e.size*1.4}];
        drawUnit(e.x, e.y, v, e.color, e.curHP/e.hp, e.size);
    });
}

function renderPlayerUnit() {
    let v = [{a:0,d:15},{a:2.5,d:12},{a:3.7,d:12}];
    drawUnit(game.player.x, game.player.y, v, '#fff', game.player.hp/game.player.maxHp, 10);
}

// --- RESZTA LOGIKI TWOJEGO KODU ---
function init() {
    window.addEventListener('keydown', e => game.keys[e.code] = true);
    window.addEventListener('keyup', e => game.keys[e.code] = false);
    canvas.addEventListener('mousemove', e => {
        const r = canvas.getBoundingClientRect();
        game.mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
        game.mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
    });
    canvas.addEventListener('mousedown', handleInput);
    updateBuildMenu(); gameLoop();
}

function generateStrategicMap() {
    game.terrain = { hills: [], lakes: [], forests: [] };
    const S = CONFIG.SCALE;
    // Pasma górskie
    for(let f=0; f<4; f++) {
        const ridgePoints = [];
        const startPos = Math.random()*900*S;
        for(let i=0; i<=15; i++) ridgePoints.push({x: (100+i/15*2200)*S, y: startPos + Math.sin(i)*50*S});
        for(let level=0; level<8; level++) {
            const points = ridgePoints.map(p => ({x: p.x, y: p.y + level*10*S}));
            game.terrain.hills.push({isRidge: true, points, level, totalLayers: 8});
        }
    }
    // Jeziora
    for(let l=0; l<3; l++) {
        const points = [];
        const cx = Math.random()*1200, cy = Math.random()*900;
        for(let i=0; i<12; i++) points.push({x: cx+Math.cos(i)*80, y: cy+Math.sin(i)*80});
        game.terrain.lakes.push({points});
    }
}

function spawnWaveLogic() {
    game.enemies = [];
    for(let i=0; i<15; i++) {
        let type = Math.random() > 0.6 ? 'SWIM' : (Math.random() > 0.8 ? 'FLY' : 'LAND');
        game.enemies.push(createEnemy(100 + game.wave*50, type));
    }
}

function gameLoop() {
    ctx.clearRect(0,0,1200,900);
    if(game.mode === 'BASE') renderBaseGrid();
    else {
        renderTacticalMap();
        if(game.mode === 'COMBAT') updateCombat();
        renderEntities(); renderAnomalies();
        if(game.corePlaced) renderPlayerUnit();
    }
    renderProjectiles(); updateStatsUI(); requestAnimationFrame(gameLoop);
}

function renderProjectiles() {
    ctx.fillStyle = "#fff";
    game.projectiles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; ctx.fillRect(p.x, p.y, 4, 4);
        let hit = game.enemies.find(e => Math.hypot(e.x-p.x, e.y-p.y) < e.size);
        if(hit) { hit.hp -= p.dmg; game.projectiles.splice(i, 1); }
        if(p.x<0||p.x>1200||p.y<0||p.y>900) game.projectiles.splice(i, 1);
    });
}

function playerShoot() {
    if(Date.now() - game.player.lastShot > 200) {
        let a = Math.atan2(game.mouse.y-game.player.y, game.mouse.x-game.player.x);
        game.projectiles.push({x: game.player.x, y: game.player.y, vx: Math.cos(a)*15, vy: Math.sin(a)*15, dmg: 40});
        game.player.lastShot = Date.now();
    }
}

function handleInput() {
    if (game.mode === 'BASE' && game.selected) {
        const gx = Math.floor((game.mouse.x - CONFIG.BASE_OFF.x) / CONFIG.CELL);
        const gy = Math.floor((game.mouse.y - CONFIG.BASE_OFF.y) / CONFIG.CELL);
        if(gx>=0 && gx<12 && gy>=0 && gy<12) {
            game.buildings.push({ gx, gy, cfg: CONFIG.BUILDINGS[game.selected] });
            game.money -= CONFIG.BUILDINGS[game.selected].cost;
        }
    } else if (game.mode === 'PREP' && game.selected) {
        const cfg = CONFIG.DEFENSE[game.selected];
        if (cfg.type === 'core' && game.corePlaced) return;
        game.entities.push({ ...cfg, x: game.mouse.x, y: game.mouse.y, curHP: cfg.hp, lastFire: 0 });
        if (cfg.type === 'core') { game.corePlaced = true; game.player.x = game.mouse.x; game.player.y = game.mouse.y; }
        else game.money -= cfg.cost;
    }
}

function renderBaseGrid() {
    ctx.strokeStyle = "#141";
    for(let i=0; i<=12; i++) {
        ctx.beginPath(); ctx.moveTo(300+i*50, 150); ctx.lineTo(300+i*50, 750); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(300, 150+i*50); ctx.lineTo(900, 150+i*50); ctx.stroke();
    }
    game.buildings.forEach(b => { ctx.fillStyle = b.cfg.color; ctx.fillRect(305+b.gx*50, 155+b.gy*50, 40, 40); });
}

function updateStatsUI() {
    document.getElementById('ui-money').innerText = `$${game.money}`;
    document.getElementById('ui-hp').innerText = `${Math.ceil(game.hp/6000*100)}%`;
}

function updateBuildMenu() {
    const menu = document.getElementById('buildMenu'); menu.innerHTML = "";
    const list = (game.mode === 'BASE') ? CONFIG.BUILDINGS : CONFIG.DEFENSE;
    for(let k in list) {
        const btn = document.createElement('button');
        btn.className = 'btn'; btn.innerHTML = `${list[k].name} $${list[k].cost}`;
        btn.onclick = () => game.selected = k; menu.appendChild(btn);
    }
}

function isPointInPolygon(x, y, points) {
    let inside = false;
    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
        let xi = points[i].x, yi = points[i].y, xj = points[j].x, yj = points[j].y;
        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside;
    }
    return inside;
}

function logTerminal(t) { document.getElementById('terminal').innerHTML += `> ${t}<br>`; }
init();
</script>
</body>
</html>

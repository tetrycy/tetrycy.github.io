<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>OUTPOST '95: SUPREME COMMANDER [PATHFINDING]</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root { --f-green: #20ff20; --f-bg: #050805; --panel: #1a1c1a; --f-red: #ff3333; --f-blue: #33aaff; --f-purple: #cc33ff; --f-hp: #ffff00; }
        body { margin: 0; background: #000; color: var(--f-green); font-family: VT323, monospace; display: flex; height: 100vh; overflow: hidden; font-size: 18px; }
        #viewport { flex-grow: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; padding: 0; min-height: 0; }
        canvas { border: 2px solid var(--f-green); background: var(--f-bg); cursor: crosshair; image-rendering: crisp-edges; max-width: 100%; max-height: 100%; width: auto; height: auto; }
        #sidebar { width: 380px; background: var(--panel); border-left: 4px ridge #444; display: flex; flex-direction: column; padding: 20px; }
        .screen { background: #000; border: 1px solid var(--f-green); padding: 15px; margin-bottom: 12px; box-shadow: inset 0 0 15px rgba(0,255,0,0.2); }
        .btn { background: #222; color: var(--f-green); border: 2px solid var(--f-green); padding: 12px; margin: 5px 0; cursor: pointer; font-family: VT323; font-size: 1.3em; text-transform: uppercase; width: 100%; text-align: left; }
        .btn:hover:not(:disabled) { background: var(--f-green); color: #000; }
        .btn.active { background: #083308; box-shadow: 0 0 10px var(--f-green); }
        .stat { display: flex; justify-content: space-between; font-size: 1.5em; margin: 5px 0; }
        #terminal { font-size: 1em; height: 160px; overflow-y: auto; color: #8f8; border: 1px solid #1a331a; padding: 8px; background: #020502; line-height: 1.3; }
        .upgrade-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-top: 8px; }
        h2 { font-size: 1.8em; margin: 0 0 15px 0; }
        select { background: #222; color: var(--f-green); border: 2px solid var(--f-green); padding: 8px; font-family: VT323; font-size: 1.1em; width: 100%; margin: 8px 0; }
        .pathfind-badge { background: #083308; color: #8f8; padding: 4px 8px; border: 1px solid #0f0; font-size: 0.9em; display: inline-block; margin-top: 5px; }
    </style>
</head>
<body>

<div id="viewport">
    <canvas id="gameCanvas" width="2400" height="1800"></canvas>
</div>

<div id="sidebar">
    <h2 style="text-align:center; border-bottom:2px solid var(--f-green); margin:0 0 10px 0;">STRAT-COM INTERFACE</h2>
    
    <div class="screen">
        <div class="stat"><span>CREDITS:</span> <span id="ui-money">$800</span></div>
        <div class="stat"><span>HQ HULL:</span> <span id="ui-hp">100%</span></div>
        <div id="unit-info" style="font-size:0.75em; color:#888; border-top:1px solid #333; margin-top:5px; padding-top:5px;">
            UNIT-01: SPD <span id="p-spd">1.0</span> | ROF <span id="p-rof">1.0</span> | DMG <span id="p-dmg">1.0</span>
        </div>
        <div id="weapon-info" style="font-size:0.75em; color:#4af; margin-top:5px;">
            <div>LMB: <span id="weapon-primary">ASSAULT RIFLE</span></div>
            <div>RMB: <span id="weapon-secondary">FRAG GRENADE</span></div>
        </div>
        <div class="pathfind-badge">✓ PATHFINDING ACTIVE</div>
    </div>

    <div class="screen" id="terminal">> PATHFINDING ENABLED<br>> Wrogowie omijają trudny teren</div>

    <div id="buildMenu" style="flex-grow: 1; overflow-y: auto;"></div>

    <button class="btn" id="actionBtn" style="background:#400; border-color:#f44; color:#f44; font-weight:bold; text-align:center;" onclick="handleAction()">EXECUTE COMBAT</button>
</div>

<script>
const CONFIG = {
    WIDTH: 2400, HEIGHT: 1800,
    GRID_SIZE: 60, // Flow field resolution
    DEFENSE: {
        CORE: { name: "HQ BUNKER", cost: 0, hp: 6000, type: 'core', color: '#0ff' },
        WALL: { name: "HEAVY WALL", cost: 0, hp: 1500, type: 'wall', color: '#666' },
        SENTRY: { name: "AUTO-TURRET", cost: 0, range: 250, dmg: 12, rof: 250, hp: 400, type: 'tower', color: '#ff0' },
        BATTERY: { name: "LR BATTERY", cost: 0, range: 420, dmg: 100, rof: 1000, hp: 600, type: 'tower', color: '#f80' },
        MORTAR: { name: "GRENADE TURRET", cost: 0, range: 380, dmg: 80, blastRadius: 100, rof: 3500, hp: 500, type: 'tower', color: '#4f4' },
        SHOTGUN_TURRET: { name: "SHOTGUN TURRET", cost: 0, range: 180, dmg: 15, pellets: 6, spread: 0.2, rof: 800, hp: 450, type: 'tower', color: '#f4f' },
        ROCKET_TURRET: { name: "ROCKET TURRET", cost: 0, range: 500, dmg: 200, blastRadius: 90, velocity: 12, rof: 4000, hp: 550, type: 'tower', color: '#f66' }
    },
    BUILDINGS: {
        SOLAR: { name: "SOLAR ARRAY", cost: 150, pwr: 50, color: "#AA0" },
        FARM: { name: "BIO-FARM", cost: 200, pwr: -10, color: "#0A0" },
        MUNITION: { name: "MUNITION FAB", cost: 450, pwr: -50, color: "#A00" }
    },
    WEAPONS_PRIMARY: {
        RIFLE: { 
            name: "ASSAULT RIFLE", cost: 0, rof: 140, dmg: 35, spread: 0, 
            velocity: 22, desc: "Balanced firepower"
        },
        MINIGUN: { 
            name: "MINIGUN", cost: 0, rof: 60, dmg: 18, spread: 0.15, 
            velocity: 26, desc: "High ROF, low accuracy"
        },
        SHOTGUN: { 
            name: "COMBAT SHOTGUN", cost: 0, rof: 600, dmg: 15, pellets: 8, spread: 0.25, 
            knockback: 18, velocity: 20, desc: "Spread damage + knockback"
        },
        SNIPER: { 
            name: "SNIPER RIFLE", cost: 0, rof: 1200, dmg: 150, spread: 0, 
            velocity: 35, desc: "High damage, slow fire"
        },
        FLAMETHROWER: { 
            name: "FLAMETHROWER", cost: 0, rof: 50, dmg: 3, range: 200, 
            continuous: true, desc: "Continuous cone damage"
        },
        RAILGUN: { 
            name: "RAILGUN", cost: 0, rof: 2000, dmg: 250, spread: 0, 
            velocity: 50, piercing: true, desc: "Pierces all enemies"
        }
    },
    WEAPONS_SECONDARY: {
        GRENADE: {
            name: "FRAG GRENADE", cost: 0, cooldown: 2500, damage: 100, 
            blastRadius: 120, range: 450, desc: "Standard explosive"
        },
        CLUSTER: {
            name: "CLUSTER BOMB", cost: 0, cooldown: 4000, damage: 60, 
            blastRadius: 80, range: 420, clusters: 6, desc: "Multiple explosions"
        },
        INCENDIARY: {
            name: "INCENDIARY", cost: 0, cooldown: 3500, damage: 25, 
            blastRadius: 150, burnTime: 80, burnDmg: 2, range: 400, desc: "Damage over time"
        },
        ROCKET: {
            name: "ROCKET LAUNCHER", cost: 0, cooldown: 3000, damage: 250, 
            blastRadius: 100, range: 600, velocity: 15, desc: "High damage projectile"
        },
        POISON: {
            name: "TOXIC GRENADE", cost: 0, cooldown: 3000, damage: 40, 
            blastRadius: 140, range: 420, poisonDmg: 3, poisonTime: 100, desc: "Poison cloud DOT"
        },
        EMP: {
            name: "EMP BLAST", cost: 0, cooldown: 4500, damage: 0, 
            blastRadius: 200, range: 450, stunTime: 60, desc: "Stuns enemies"
        },
        BANANA: {
            name: "BANANA GRENADE", cost: 0, cooldown: 5000, damage: 80,
            blastRadius: 100, range: 450, bananas: 7, desc: "Splits into 7 bananas!"
        }
    }
};

let game = {
    money: 800, hp: 6000, wave: 0, mode: 'BASE',
    buildings: [], entities: [], enemies: [], projectiles: [],
    grenades: [], explosions: [], burnZones: [], rockets: [], towerGrenades: [],
    poisonClouds: [], // NEW: Poison gas areas
    terrain: { hills: [], lakes: [], forests: [] },
    selected: null, corePlaced: false,
    mouse: { x:0, y:0, down: false, rightDown: false },
    keys: {},
    player: { 
        x: 1200, y: 900, spd: 3.5, spdLv: 1, rofLv: 1, dmgLv: 1, 
        lastShot: 0, lastGrenade: 0,
        primaryWeapon: 'RIFLE',
        secondaryWeapon: 'GRENADE',
        ownedWeapons: { 
            // TEST MODE: All weapons unlocked from start
            RIFLE: true, MINIGUN: true, SHOTGUN: true, SNIPER: true, FLAMETHROWER: true, RAILGUN: true,
            GRENADE: true, CLUSTER: true, INCENDIARY: true, ROCKET: true, POISON: true, EMP: true, BANANA: true
        }
    },
    spawnDir: 'NORTH',
    intel: { land: 0, swim: 0, air: 0, totalHP: 0 },
    mapView: 'DETAILED',
    selectedCustomMap: null,
    flowField: { land: null, swim: null, fly: null },
    debugPathfinding: false
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function init() {
    window.addEventListener('keydown', e => game.keys[e.code] = true);
    window.addEventListener('keyup', e => game.keys[e.code] = false);
    canvas.addEventListener('mousemove', e => {
        const r = canvas.getBoundingClientRect();
        game.mouse.x = (e.clientX - r.left) * (CONFIG.WIDTH / r.width);
        game.mouse.y = (e.clientY - r.top) * (CONFIG.HEIGHT / r.height);
    });
    canvas.addEventListener('mousedown', (e) => { 
        if (e.button === 0) { // Left click
            game.mouse.down = true; 
            handleInput(); 
        } else if (e.button === 2) { // Right click
            game.mouse.rightDown = true;
            if (game.mode === 'COMBAT' && game.corePlaced) {
                throwGrenade();
            }
        }
    });
    canvas.addEventListener('mouseup', (e) => {
        if (e.button === 0) game.mouse.down = false;
        if (e.button === 2) game.mouse.rightDown = false;
    });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Disable right-click menu
    updateBuildMenu();
    gameLoop();
}

function handleAction() {
    if (game.mode === 'BASE') {
        game.mode = 'PREP'; game.wave++; game.entities = []; game.corePlaced = false;
        
        if (game.selectedCustomMap) {
            loadCustomMap(game.selectedCustomMap);
        } else {
            generateStrategicMap();
        }
        
        spawnWaveLogic();
        updateBuildMenu();
        document.getElementById('actionBtn').innerText = "LOCK ALL UNITS";
        showIntelReport();
    } else if (game.mode === 'PREP') {
        if (!game.corePlaced) { logTerminal("CRITICAL: HQ MUST BE DEPLOYED."); return; }
        
        const core = game.entities.find(e => e.type === 'core');
        if (core) {
            logTerminal("CALCULATING PATHFINDING...");
            game.flowField.land = calculateFlowField(core.x, core.y, 'LAND');
            game.flowField.swim = calculateFlowField(core.x, core.y, 'SWIM');
            game.flowField.fly = calculateFlowField(core.x, core.y, 'FLY');
            logTerminal("✓ PATHFINDING READY");
        }
        
        game.mode = 'COMBAT';
        document.getElementById('actionBtn').innerText = "IN COMBAT";
        document.getElementById('actionBtn').disabled = true;
    }
}

// FIXED: Calculate terrain cost - lakes override mountains for SWIM units
function getTerrainCost(x, y, moveType, entityRadius = 0) {
    let cost = 1.0;
    
    // FIXED: Check lakes with entity radius - check if ANY part of entity touches water
    let inLake = false;
    let touchesLake = false;
    
    game.terrain.lakes.forEach(lake => {
        // Check center point
        if (isPointInPolygon(x, y, lake.points)) {
            inLake = true;
        }
        
        // If entity has radius, check if it touches lake (check 8 points around entity)
        if (entityRadius > 0 && !inLake) {
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                const checkX = x + Math.cos(angle) * entityRadius;
                const checkY = y + Math.sin(angle) * entityRadius;
                if (isPointInPolygon(checkX, checkY, lake.points)) {
                    touchesLake = true;
                    break;
                }
            }
        }
    });
    
    // If center OR edge touches lake
    if (inLake || touchesLake) {
        if (moveType === 'LAND') {
            // CRITICAL: LAND units avoid water completely
            cost = 10000.0; // Extreme cost - pathfinder treats as impassable
        } else if (moveType === 'SWIM') {
            cost = 0.3; // Super cheap - ignore all other terrain!
            // SWIM in lake ignores mountains/forests - return immediately
            return cost;
        }
    }
    
    // If SWIM in lake, return immediately (ignore mountains/forests)
    if (inLake && moveType === 'SWIM') {
        return cost;
    }

// NEW FUNCTION: Check if moving in a direction will cause collision with lake
function willCollideWithLake(x, y, dirX, dirY, size, moveType) {
    if (moveType !== 'LAND') return false; // Only LAND units care
    
    // Check multiple points along the movement trajectory (prevent tunneling)
    const steps = 3; // Check 3 intermediate positions
    for (let step = 1; step <= steps; step++) {
        const t = step / steps;
        const checkX = x + dirX * t;
        const checkY = y + dirY * t;
        
        // Check multiple points around the entity's perimeter at this position
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) { // 12 points
            const perimeterX = checkX + Math.cos(angle) * size;
            const perimeterY = checkY + Math.sin(angle) * size;
            
            for (let lake of game.terrain.lakes) {
                if (isPointInPolygon(perimeterX, perimeterY, lake.points)) {
                    return true; // Collision detected!
                }
            }
        }
    }
    
    return false;
}
    
    // Mountains (only if not SWIM in lake)
    if (!inLake || moveType !== 'SWIM') {
        game.terrain.hills.forEach(h => {
            const height = h.height || 5;
            const baseSlowdown = 0.15 + (height / 15) * 0.60;
            
            if (h.isRidge) {
                let minDist = Infinity;
                
                for (let i = 0; i < h.points.length - 1; i++) {
                    const p1 = h.points[i];
                    const p2 = h.points[i + 1];
                    const segmentDist = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    minDist = Math.min(minDist, segmentDist);
                }
                
                h.points.forEach(p => {
                    const dist = Math.hypot(x - p.x, y - p.y);
                    minDist = Math.min(minDist, dist);
                });
                
                const elevationFactor = 1 - (h.level / h.totalLayers);
                const width = 120 * elevationFactor;
                
                if (minDist < width) {
                    const depth = 1 - (minDist / width);
                    if (moveType !== 'FLY') {
                        cost += depth * baseSlowdown * 8;
                    }
                }
            } else {
                const dist = Math.hypot(x - h.x, y - h.y);
                const outerRadius = h.layers[0] ? h.layers[0].radius : 100;
                if (dist < outerRadius) {
                    const depth = 1 - (dist / outerRadius);
                    if (moveType !== 'FLY') {
                        cost += depth * baseSlowdown * 8;
                    }
                }
            }
        });
    }
    
    // Forests affect ONLY FLY units
    game.terrain.forests.forEach(forest => {
        const dist = Math.hypot(x - forest.centerX, y - forest.centerY);
        if (dist < forest.radius && moveType === 'FLY') {
            cost += 2.33; // FLY units slow to 0.3x speed (1/0.3 ≈ 3.33, so +2.33)
        }
    });
    
    return cost;
}

function distanceToSegment(x, y, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lengthSquared = dx * dx + dy * dy;
    
    if (lengthSquared === 0) {
        return Math.hypot(x - x1, y - y1);
    }
    
    let t = ((x - x1) * dx + (y - y1) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t));
    
    const projX = x1 + t * dx;
    const projY = y1 + t * dy;
    
    return Math.hypot(x - projX, y - projY);
}

function calculateFlowField(targetX, targetY, moveType) {
    const gridCols = Math.ceil(CONFIG.WIDTH / CONFIG.GRID_SIZE);
    const gridRows = Math.ceil(CONFIG.HEIGHT / CONFIG.GRID_SIZE);
    
    const costs = Array(gridRows).fill(null).map(() => Array(gridCols).fill(Infinity));
    const directions = Array(gridRows).fill(null).map(() => Array(gridCols).fill(null));
    
    const targetCol = Math.floor(targetX / CONFIG.GRID_SIZE);
    const targetRow = Math.floor(targetY / CONFIG.GRID_SIZE);
    
    if (targetCol < 0 || targetCol >= gridCols || targetRow < 0 || targetRow >= gridRows) {
        return { costs, directions, gridCols, gridRows };
    }
    
    costs[targetRow][targetCol] = 0;
    
    const queue = [{col: targetCol, row: targetRow, cost: 0}];
    
    while (queue.length > 0) {
        queue.sort((a, b) => a.cost - b.cost);
        const current = queue.shift();
        
        const {col, row, cost} = current;
        
        if (cost > costs[row][col]) continue;
        
        const neighbors = [
            {dc: -1, dr: 0}, {dc: 1, dr: 0}, {dc: 0, dr: -1}, {dc: 0, dr: 1},
            {dc: -1, dr: -1}, {dc: 1, dr: -1}, {dc: -1, dr: 1}, {dc: 1, dr: 1}
        ];
        
        for (let {dc, dr} of neighbors) {
            const newCol = col + dc;
            const newRow = row + dr;
            
            if (newCol < 0 || newCol >= gridCols || newRow < 0 || newRow >= gridRows) continue;
            
            const cellX = newCol * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
            const cellY = newRow * CONFIG.GRID_SIZE + CONFIG.GRID_SIZE / 2;
            const terrainCost = getTerrainCost(cellX, cellY, moveType);
            
            const moveCost = (dc !== 0 && dr !== 0) ? 1.414 : 1.0;
            const newCost = cost + moveCost * terrainCost;
            
            if (newCost < costs[newRow][newCol]) {
                costs[newRow][newCol] = newCost;
                queue.push({col: newCol, row: newRow, cost: newCost});
            }
        }
    }
    
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            if (costs[row][col] === Infinity) continue;
            if (row === targetRow && col === targetCol) continue;
            
            let bestCost = costs[row][col];
            let bestDx = 0, bestDy = 0;
            
            const neighbors = [
                {dc: -1, dr: 0}, {dc: 1, dr: 0}, {dc: 0, dr: -1}, {dc: 0, dr: 1},
                {dc: -1, dr: -1}, {dc: 1, dr: -1}, {dc: -1, dr: 1}, {dc: 1, dr: 1}
            ];
            
            for (let {dc, dr} of neighbors) {
                const nCol = col + dc;
                const nRow = row + dr;
                
                if (nCol < 0 || nCol >= gridCols || nRow < 0 || nRow >= gridRows) continue;
                
                if (costs[nRow][nCol] < bestCost) {
                    bestCost = costs[nRow][nCol];
                    bestDx = dc;
                    bestDy = dr;
                }
            }
            
            if (bestDx !== 0 || bestDy !== 0) {
                directions[row][col] = {dx: bestDx, dy: bestDy};
            }
        }
    }
    
    return { costs, directions, gridCols, gridRows };
}

function getFlowDirection(x, y, flowField) {
    if (!flowField || !flowField.directions) return {dx: 0, dy: 0};
    
    const col = Math.floor(x / CONFIG.GRID_SIZE);
    const row = Math.floor(y / CONFIG.GRID_SIZE);
    
    if (col < 0 || col >= flowField.gridCols || row < 0 || row >= flowField.gridRows) {
        return {dx: 0, dy: 0};
    }
    
    const dir = flowField.directions[row][col];
    return dir || {dx: 0, dy: 0};
}

function loadCustomMap(mapName) {
    const maps = JSON.parse(localStorage.getItem('outpost_maps') || '{}');
    if (maps[mapName]) {
        game.terrain = JSON.parse(JSON.stringify(maps[mapName].terrain));
        
        const scaleX = CONFIG.WIDTH / 1200;
        const scaleY = CONFIG.HEIGHT / 900;
        
        game.terrain.hills.forEach(h => {
            if (h.isRidge) {
                h.points.forEach(p => {
                    p.x *= scaleX;
                    p.y *= scaleY;
                });
            } else {
                h.x *= scaleX;
                h.y *= scaleY;
                h.layers.forEach(layer => {
                    layer.radius *= scaleX;
                    layer.verts.forEach(v => {
                        v.x *= scaleX;
                        v.y *= scaleY;
                    });
                });
            }
        });
        
        game.terrain.lakes.forEach(lake => {
            lake.points.forEach(p => {
                p.x *= scaleX;
                p.y *= scaleY;
            });
        });
        
        game.terrain.forests.forEach(forest => {
            forest.centerX *= scaleX;
            forest.centerY *= scaleY;
            forest.radius *= scaleX;
            forest.trees.forEach(tree => {
                tree.x *= scaleX;
                tree.y *= scaleY;
                tree.size *= scaleX;
            });
        });
        
        logTerminal(`CUSTOM MAP LOADED: ${mapName}`);
    } else {
        logTerminal("MAP NOT FOUND - GENERATING RANDOM");
        generateStrategicMap();
    }
}

function showIntelReport() {
    logTerminal(`--- INTEL REPORT WAVE ${game.wave} ---`);
    logTerminal(`FRONT: ${game.spawnDir} BORDER`);
    logTerminal(`HOSTILES: ${game.enemies.length} SIGNATURES`);
    logTerminal(`L:${game.intel.land} S:${game.intel.swim} A:${game.intel.air}`);
    logTerminal(`TOTAL MASS: ${Math.floor(game.intel.totalHP)} HP`);
    if (game.wave === 1) {
        logTerminal(`--- ARSENAL AVAILABLE ---`);
        logTerminal(`TOWERS: SENTRY/BATTERY/MORTAR/SHOTGUN/ROCKET`);
        logTerminal(`PRIMARY: RIFLE/MINIGUN/SHOTGUN/SNIPER/FLAMETHROWER/RAILGUN`);
        logTerminal(`SECONDARY: GRENADE/CLUSTER/INCENDIARY/ROCKET/POISON/EMP/BANANA`);
    }
}

function generateStrategicMap() {
    game.spawnDir = ['NORTH', 'SOUTH', 'EAST', 'WEST'][Math.floor(Math.random() * 4)];
    game.terrain = { hills: [], lakes: [], forests: [] };
    
    const S = 1;
    
    function createMountain(centerX, centerY, baseRadius, totalLayers) {
        const mountain = { x: centerX, y: centerY, layers: [], totalLayers, height: totalLayers };
        
        for(let l = 0; l < totalLayers; l++) {
            const radius = baseRadius * (1 - l / totalLayers);
            const verts = [];
            const segments = 25;
            const seed = Math.random() * 100;
            const noiseAmount = 0.4;
            
            for(let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const noise = noiseAmount * radius * ((Math.sin(angle * 3 + seed) * 0.5) + (Math.sin(angle * 7) * 0.3));
                const r = radius + noise;
                verts.push({
                    x: Math.cos(angle) * r,
                    y: Math.sin(angle) * r
                });
            }
            
            mountain.layers.push({ verts, radius, level: l });
        }
        
        game.terrain.hills.push(mountain);
    }
    
    function createRidge(startX, startY, ridgeLength, ridgeAngle, layers) {
        const endX = startX + Math.cos(ridgeAngle) * ridgeLength;
        const endY = startY + Math.sin(ridgeAngle) * ridgeLength;
        
        const segments = 8 + Math.floor(Math.random() * 6);
        const ridgePoints = [];
        
        for(let s = 0; s < segments; s++) {
            const t = s / (segments - 1);
            const curvature = (Math.random() - 0.5) * 300 * S;
            const perpX = -Math.sin(ridgeAngle);
            const perpY = Math.cos(ridgeAngle);
            
            ridgePoints.push({
                x: startX * (1 - t) + endX * t + perpX * curvature,
                y: startY * (1 - t) + endY * t + perpY * curvature
            });
        }
        
        const maxHeight = (100 + Math.random() * 100) * S;
        
        for(let level = 0; level < layers; level++) {
            const elevation = level / layers;
            const currentHeight = maxHeight * (1 - elevation);
            
            for(let side of [-1, 1]) {
                const points = [];
                
                for(let i = 0; i < ridgePoints.length; i++) {
                    const ridge = ridgePoints[i];
                    
                    const t = i / (ridgePoints.length - 1);
                    const peakPos = 0.5;
                    const peakness = 1 - Math.abs(t - peakPos) / Math.max(peakPos, 1 - peakPos);
                    const heightHere = maxHeight * peakness * (0.6 + Math.random() * 0.4);
                    
                    if(heightHere < currentHeight) continue;
                    
                    const width = (heightHere - currentHeight) * 0.7;
                    
                    let perpX, perpY;
                    if(i < ridgePoints.length - 1) {
                        const next = ridgePoints[i + 1];
                        const dx = next.x - ridge.x;
                        const dy = next.y - ridge.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        perpX = -dy / len;
                        perpY = dx / len;
                    } else {
                        const prev = ridgePoints[i - 1];
                        const dx = ridge.x - prev.x;
                        const dy = ridge.y - prev.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        perpX = -dy / len;
                        perpY = dx / len;
                    }
                    
                    points.push({
                        x: ridge.x + perpX * width * side,
                        y: ridge.y + perpY * width * side
                    });
                }
                
                if(points.length > 3) {
                    game.terrain.hills.push({
                        isRidge: true,
                        points: points,
                        level: level,
                        totalLayers: layers,
                        height: layers
                    });
                }
            }
        }
    }
    
    function createLake(centerX, centerY, radius) {
        const points = [];
        const segments = 20;
        for(let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const r = radius * (0.8 + Math.random() * 0.4);
            points.push({
                x: centerX + Math.cos(angle) * r,
                y: centerY + Math.sin(angle) * r
            });
        }
        game.terrain.lakes.push({ points, type: 'sulfur' });
    }
    
    function createForest(centerX, centerY, radius, density) {
        const trees = [];
        for(let t = 0; t < density; t++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * radius;
            trees.push({
                x: centerX + Math.cos(angle) * dist,
                y: centerY + Math.sin(angle) * dist,
                size: 6 + Math.random() * 8
            });
        }
        game.terrain.forests.push({ trees, centerX, centerY, radius });
    }
    
    // Góry: 0-15
    const mountainCount = Math.floor(Math.random() * 16);
    
    for(let i = 0; i < mountainCount; i++) {
        const mountainType = Math.random();
        const x = 300 + Math.random() * 1800;
        const y = 300 + Math.random() * 1200;
        
        if(mountainType < 0.3) {
            createRidge(
                x, y,
                400 + Math.random() * 1000,
                Math.random() * Math.PI * 2,
                3 + Math.floor(Math.random() * 15)
            );
        } else if(mountainType < 0.7) {
            createMountain(
                x, y,
                50 + Math.random() * 250,
                3 + Math.floor(Math.random() * 18)
            );
        } else {
            const clusterSize = 2 + Math.floor(Math.random() * 4);
            for(let c = 0; c < clusterSize; c++) {
                createMountain(
                    x + (Math.random() - 0.5) * 300,
                    y + (Math.random() - 0.5) * 300,
                    40 + Math.random() * 100,
                    3 + Math.floor(Math.random() * 8)
                );
            }
        }
    }
    
    // Jeziora: 0-12
    const lakeCount = Math.floor(Math.random() * 13);
    
    for(let i = 0; i < lakeCount; i++) {
        createLake(
            400 + Math.random() * 1600,
            300 + Math.random() * 1200,
            40 + Math.random() * 200
        );
    }
    
    // FIXED: Lasy: 3-18 (więcej lasów!)
    const forestCount = 3 + Math.floor(Math.random() * 16);
    
    for(let i = 0; i < forestCount; i++) {
        createForest(
            400 + Math.random() * 1600,
            300 + Math.random() * 1200,
            80 + Math.random() * 140,  // promień: 80-220 (większe lasy)
            15 + Math.floor(Math.random() * 40)  // gęstość: 15-54 drzew (więcej drzew)
        );
    }
    
    logTerminal(`Wygenerowano: G:${game.terrain.hills.length} J:${game.terrain.lakes.length} L:${game.terrain.forests.length}`);
}

function spawnWaveLogic() {
    game.enemies = [];
    game.intel = { land: 0, swim: 0, air: 0, totalHP: 0 };
    let pool = 3000 + (game.wave * 4000);
    const r1 = Math.random(), r2 = Math.random(), r3 = Math.random();
    const total = r1+r2+r3;

    while (pool > 0) {
        const r = Math.random();
        let moveType = 'FLY';
        if (r < r1/total) { moveType = 'LAND'; game.intel.land++; }
        else if (r < (r1+r2)/total) { moveType = 'SWIM'; game.intel.swim++; }
        else { game.intel.air++; }

        let hp = 50 + Math.random() * 300;
        if (Math.random() > 0.9) hp = 800 + Math.random() * 800;
        
        game.enemies.push(createEnemy(hp, moveType));
        game.intel.totalHP += hp;
        pool -= hp;
    }
}

// FIXED: Size proportional to HP, speed inversely proportional to size
function createEnemy(hp, moveType) {
    let x, y, off = 300;
    if(game.spawnDir === 'NORTH') { x = Math.random()*CONFIG.WIDTH; y = -off - Math.random()*1500; }
    else if(game.spawnDir === 'SOUTH') { x = Math.random()*CONFIG.WIDTH; y = CONFIG.HEIGHT + off + Math.random()*1500; }
    else if(game.spawnDir === 'EAST') { x = CONFIG.WIDTH + off + Math.random()*1500; y = Math.random()*CONFIG.HEIGHT; }
    else { x = -off - Math.random()*1500; y = Math.random()*CONFIG.HEIGHT; }

    // Size based on HP with some randomness
    const baseSize = 8 + (hp / 80); // 50 HP ≈ 8.6, 1500 HP ≈ 26.75
    const size = baseSize + (Math.random() - 0.5) * 4; // ±2 variance
    
    // Speed inversely proportional to size
    let baseSpeed;
    if (moveType === 'FLY') {
        baseSpeed = 1.2 + (20 / size); // Flying units: 1.9 to 3.7
    } else {
        baseSpeed = 0.8 + (15 / size); // Ground/water: 1.3 to 2.6
    }
    
    const vertices = [];
    let color;
    
    if(moveType === 'LAND') {
        color = '#ff3333';
        const sides = 4 + Math.floor(Math.random() * 3);
        for(let i = 0; i < sides; i++) {
            const a = (i / sides) * Math.PI * 2;
            const d = size * (1.2 + Math.random() * 0.3);
            vertices.push({x: Math.cos(a)*d, y: Math.sin(a)*d, bD: d});
        }
    } else if(moveType === 'SWIM') {
        color = '#33aaff';
        const pts = 20;
        for(let i = 0; i < pts; i++) {
            const a = (i / pts) * Math.PI * 2;
            const d = size * (0.8 + Math.random() * 0.3);
            vertices.push({x: Math.cos(a) * d * 1.8, y: Math.sin(a) * d * 0.6, bD: d});
        }
    } else {
        color = '#cc33ff';
        const pts = 3 + Math.floor(Math.random() * 2);
        for(let i = 0; i < pts; i++) {
            const a = (i / pts) * Math.PI * 2;
            const d = size * (1.0 + Math.random() * 0.5);
            const scale = i === 0 ? 1.5 : 1.0;
            vertices.push({x: Math.cos(a)*d*scale, y: Math.sin(a)*d, bD: d});
        }
    }
    
    return { 
        x, y, hp, maxHp: hp, moveType, size, vertices, color, 
        speed: baseSpeed, 
        hitF: 0 
    };
}

function gameLoop() {
    ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
    if (game.mode === 'BASE') renderBaseGrid();
    else {
        renderTacticalMap();
        renderBurnZones();
        renderPoisonClouds();
        if (game.mode === 'COMBAT') updateCombat();
        renderEntities();
        renderAnomalies();
        if (game.corePlaced) renderPlayerUnit();
        if (game.mode === 'PREP' && game.selected) renderGhost();
        renderGrenades();
        renderRockets();
        renderTowerGrenades();
        renderExplosions();
    }
    renderProjectiles();
    updateStatsUI();
    requestAnimationFrame(gameLoop);
}

function updateCombat() {
    // Player movement with terrain cost (player moves like LAND unit)
    // Player has radius ~12px (diamond shape)
    let pSpd = game.player.spd * (1 + (game.player.spdLv-1)*0.2);
    const terrainCost = getTerrainCost(game.player.x, game.player.y, 'LAND', 12);
    const terrainMult = 1.0 / terrainCost;
    pSpd *= terrainMult;
    
    // Calculate intended movement
    let moveX = 0, moveY = 0;
    if (game.keys['KeyW']) moveY -= pSpd;
    if (game.keys['KeyS']) moveY += pSpd;
    if (game.keys['KeyA']) moveX -= pSpd;
    if (game.keys['KeyD']) moveX += pSpd;
    
    // CRITICAL FIX: Check if movement will cause lake collision
    if ((moveX !== 0 || moveY !== 0) && willCollideWithLake(game.player.x, game.player.y, moveX, moveY, 12, 'LAND')) {
        // Try moving in only one axis (slide along edge)
        if (moveX !== 0 && !willCollideWithLake(game.player.x, game.player.y, moveX, 0, 12, 'LAND')) {
            moveY = 0; // Only horizontal movement
        } else if (moveY !== 0 && !willCollideWithLake(game.player.x, game.player.y, 0, moveY, 12, 'LAND')) {
            moveX = 0; // Only vertical movement
        } else {
            // Both axes would collide, stop completely
            moveX = 0;
            moveY = 0;
        }
    }
    
    game.player.x += moveX;
    game.player.y += moveY;
    game.player.x = Math.max(5, Math.min(CONFIG.WIDTH-5, game.player.x));
    game.player.y = Math.max(5, Math.min(CONFIG.HEIGHT-5, game.player.y));

    if (game.mouse.down) playerShoot();

    const core = game.entities.find(e => e.type === 'core');
    if (!core) return;
    
    const now = Date.now();

    game.enemies.forEach((e, i) => {
        // Handle stun effect
        if (e.stunned) {
            e.stunTimer = e.stunTimer || 0;
            e.stunTimer--;
            
            if (e.stunTimer <= 0) {
                e.stunned = false;
                e.speed = e.originalSpeed || e.speed;
            }
            
            // Visual indicator for stunned enemies
            ctx.strokeStyle = "rgba(0,200,255,0.7)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size + 5, 0, Math.PI * 2);
            ctx.stroke();
            
            // Small sparks
            for (let s = 0; s < 3; s++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = e.size + Math.random() * 10;
                ctx.fillStyle = "rgba(100,200,255,0.8)";
                ctx.fillRect(
                    e.x + Math.cos(angle) * dist - 1,
                    e.y + Math.sin(angle) * dist - 1,
                    2, 2
                );
            }
        }
        
        let flowField = null;
        if (e.moveType === 'LAND') flowField = game.flowField.land;
        else if (e.moveType === 'SWIM') flowField = game.flowField.swim;
        else if (e.moveType === 'FLY') flowField = game.flowField.fly;
        
        let dirX, dirY;
        
        if (flowField && flowField.directions) {
            const dir = getFlowDirection(e.x, e.y, flowField);
            dirX = dir.dx;
            dirY = dir.dy;
            
            const len = Math.sqrt(dirX*dirX + dirY*dirY);
            if (len > 0) {
                dirX /= len;
                dirY /= len;
            } else {
                const ang = Math.atan2(core.y - e.y, core.x - e.x);
                dirX = Math.cos(ang);
                dirY = Math.sin(ang);
            }
        } else {
            const ang = Math.atan2(core.y - e.y, core.x - e.x);
            dirX = Math.cos(ang);
            dirY = Math.sin(ang);
        }
        
        let terrainMult = 1.0;
        
        // FIXED: Pass enemy size to check if edges touch water
        const cost = getTerrainCost(e.x, e.y, e.moveType, e.size);
        terrainMult = 1.0 / cost;
        
        // CRITICAL FIX: Predict collision with lake and correct direction
        if (e.moveType === 'LAND' && willCollideWithLake(e.x, e.y, dirX * e.speed * terrainMult, dirY * e.speed * terrainMult, e.size, e.moveType)) {
            // Collision predicted! Try to slide along the edge (tangent direction)
            // Try perpendicular directions
            const perpDirs = [
                {dx: -dirY, dy: dirX},  // 90° counterclockwise
                {dx: dirY, dy: -dirX},  // 90° clockwise
                {dx: dirX * 0.5 - dirY * 0.5, dy: dirY * 0.5 + dirX * 0.5},  // 45° ccw
                {dx: dirX * 0.5 + dirY * 0.5, dy: dirY * 0.5 - dirX * 0.5}   // 45° cw
            ];
            
            let foundSafe = false;
            for (let altDir of perpDirs) {
                const len = Math.sqrt(altDir.dx * altDir.dx + altDir.dy * altDir.dy);
                const normDx = altDir.dx / len;
                const normDy = altDir.dy / len;
                
                if (!willCollideWithLake(e.x, e.y, normDx * e.speed * terrainMult, normDy * e.speed * terrainMult, e.size, e.moveType)) {
                    dirX = normDx;
                    dirY = normDy;
                    foundSafe = true;
                    break;
                }
            }
            
            // If no safe direction, stop movement
            if (!foundSafe) {
                terrainMult = 0;
            }
        }
        
        e.x += dirX * e.speed * terrainMult;
        e.y += dirY * e.speed * terrainMult;

        e.vertices.forEach(v => {
            const jitter = (Math.random()-0.5)*2.5;
            const a = Math.atan2(v.y, v.x);
            v.x = Math.cos(a) * (v.bD + jitter);
            v.y = Math.sin(a) * (v.bD + jitter);
        });

        game.entities.forEach(ent => {
            if (ent.type === 'mine') return;
            if (Math.hypot(e.x - ent.x, e.y - ent.y) < e.size + 15) {
                ent.curHP -= e.hp; game.enemies.splice(i, 1);
                if (ent.type === 'core') game.hp = Math.max(0, ent.curHP);
            }
        });
    });

    game.entities.forEach(u => {
        if (u.type === 'tower' && now - u.lastFire > u.rof) {
            const target = game.enemies.find(e => Math.hypot(e.x - u.x, e.y - u.y) < u.range);
            if (target) {
                if (u.name === 'GRENADE TURRET') {
                    // Launch grenade
                    game.towerGrenades.push({
                        x: u.x,
                        y: u.y,
                        targetX: target.x,
                        targetY: target.y,
                        startX: u.x,
                        startY: u.y,
                        progress: 0,
                        speed: 0.04, // Slower than player grenades
                        damage: u.dmg,
                        blastRadius: u.blastRadius
                    });
                    u.lastFire = now;
                } else if (u.name === 'SHOTGUN TURRET') {
                    // Fire shotgun pellets
                    const baseAngle = Math.atan2(target.y - u.y, target.x - u.x);
                    for (let i = 0; i < u.pellets; i++) {
                        const spread = (Math.random() - 0.5) * u.spread;
                        const angle = baseAngle + spread;
                        game.projectiles.push({
                            x: u.x,
                            y: u.y,
                            vx: Math.cos(angle) * 20,
                            vy: Math.sin(angle) * 20,
                            dmg: u.dmg,
                            isShotgun: true
                        });
                    }
                    u.lastFire = now;
                    
                    // Visual effect
                    ctx.strokeStyle = "rgba(255,100,255,0.6)";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(u.x, u.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.stroke();
                } else if (u.name === 'ROCKET TURRET') {
                    // Launch rocket
                    const angle = Math.atan2(target.y - u.y, target.x - u.x);
                    game.rockets.push({
                        x: u.x,
                        y: u.y,
                        vx: Math.cos(angle) * u.velocity,
                        vy: Math.sin(angle) * u.velocity,
                        damage: u.dmg,
                        blastRadius: u.blastRadius,
                        trail: [],
                        fromTower: true
                    });
                    u.lastFire = now;
                } else {
                    target.hp -= u.dmg; 
                    target.hitF = 3; 
                    u.lastFire = now;
                    
                    // Visual effect based on tower type
                    if (u.name === 'LR BATTERY') {
                        // Stronger visual for BATTERY
                        ctx.strokeStyle = "rgba(255,140,0,0.9)";
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(u.x, u.y);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();
                        
                        // Impact flash
                        ctx.fillStyle = "rgba(255,200,0,0.6)";
                        ctx.beginPath();
                        ctx.arc(target.x, target.y, 15, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Normal AUTO-TURRET visual
                        ctx.strokeStyle = "rgba(255,255,0,0.5)";
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(u.x, u.y);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();
                    }
                }
            }
        }
    });

    game.enemies = game.enemies.filter(e => { if (e.hp <= 0) { game.money += 15; return false; } return true; });
    if (game.enemies.length === 0) { game.mode = 'BASE'; document.getElementById('actionBtn').innerText = "EXECUTE COMBAT"; document.getElementById('actionBtn').disabled = false; logTerminal("THREATS NEUTRALIZED."); }
    if (game.hp <= 0) { alert("HQ OVERRUN"); location.reload(); }
}

function isPointInPolygon(x, y, points) {
    let inside = false;
    for(let i = 0, j = points.length - 1; i < points.length; j = i++) {
        const xi = points[i].x, yi = points[i].y;
        const xj = points[j].x, yj = points[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if(intersect) inside = !inside;
    }
    return inside;
}

function renderAnomalies() {
    game.enemies.forEach(e => {
        ctx.fillStyle = e.hitF > 0 ? "#fff" : e.color;
        ctx.beginPath(); ctx.moveTo(e.x + e.vertices[0].x, e.y + e.vertices[0].y);
        for(let v=1; v<e.vertices.length; v++) ctx.lineTo(e.x + e.vertices[v].x, e.y + e.vertices[v].y);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.stroke();
        
        // Visual indicator when slowed by terrain
        const terrainCost = getTerrainCost(e.x, e.y, e.moveType, e.size);
        if (terrainCost > 1.5) {
            // Show red ring when significantly slowed
            ctx.strokeStyle = "rgba(255, 50, 50, 0.7)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size + 4, 0, Math.PI * 2);
            ctx.stroke();
        }

        const barW = Math.max(25, e.size * 2);
        ctx.fillStyle = "#400"; ctx.fillRect(e.x - barW/2, e.y - e.size - 15, barW, 6);
        ctx.fillStyle = "#ffff00";
        ctx.fillRect(e.x - barW/2, e.y - e.size - 15, barW * (e.hp/e.maxHp), 6);
        if(e.hitF > 0) e.hitF--;
    });
}

function renderTacticalMap() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
    
    if(game.mapView === 'DETAILED') {
        ctx.strokeStyle = "rgba(0, 100, 0, 0.05)";
        ctx.lineWidth = 1;
        for(let i=0; i<=CONFIG.WIDTH; i+=300) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, CONFIG.HEIGHT);
            ctx.stroke();
        }
        for(let i=0; i<=CONFIG.HEIGHT; i+=300) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(CONFIG.WIDTH, i);
            ctx.stroke();
        }
    }
    
    game.terrain.lakes.forEach(lake => {
        ctx.fillStyle = "rgba(150, 180, 50, 0.4)";
        ctx.beginPath();
        lake.points.forEach((p, i) => {
            if(i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        });
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#9a0";
        ctx.lineWidth = 2;
        ctx.stroke();
    });
    
    game.terrain.forests.forEach(forest => {
        forest.trees.forEach(tree => {
            ctx.fillStyle = "rgba(150, 50, 200, 0.6)";
            ctx.beginPath();
            ctx.arc(tree.x, tree.y, tree.size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = "rgba(180, 100, 255, 0.3)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(tree.x, tree.y, tree.size + 3, 0, Math.PI * 2);
            ctx.stroke();
        });
    });
    
    game.terrain.hills.forEach(h => {
        if(h.isRidge) {
            if(game.mapView === 'SIMPLIFIED' && h.level % 3 !== 0) return;
            
            const elevation = h.level / h.totalLayers;
            const height = h.height || 5;
            const heightIntensity = (height - 1) / 14;
            
            let r, g, b;
            if(elevation < 0.3) {
                r = 20 + elevation * 100 + heightIntensity * 60;
                g = 30 + elevation * 120 + heightIntensity * 70;
                b = 10 + elevation * 80 + heightIntensity * 50;
            } else if(elevation < 0.6) {
                const t = (elevation - 0.3) / 0.3;
                r = 50 + t * 80 + heightIntensity * 70;
                g = 60 + t * 80 + heightIntensity * 80;
                b = 30 + t * 60 + heightIntensity * 90;
            } else {
                const t = (elevation - 0.6) / 0.4;
                r = 130 + t * 90 + heightIntensity * 35;
                g = 140 + t * 90 + heightIntensity * 40;
                b = 90 + t * 120 + heightIntensity * 85;
            }
            
            const isEveryFifth = h.level % 5 === 0;
            const lineWidth = game.mapView === 'SIMPLIFIED' ? 2 : (isEveryFifth ? 2.5 : 1.2);
            
            ctx.strokeStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
            ctx.lineWidth = lineWidth;
            
            ctx.beginPath();
            h.points.forEach((p, i) => {
                if(i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
            
        } else {
            h.layers.forEach(layer => {
                if(game.mapView === 'SIMPLIFIED' && layer.level % 3 !== 0) return;
                
                const elevation = layer.level / h.totalLayers;
                const height = h.height || 5;
                const heightIntensity = (height - 1) / 14;
                
                let r, g, b;
                if(elevation < 0.3) {
                    r = 20 + elevation * 100 + heightIntensity * 60;
                    g = 30 + elevation * 120 + heightIntensity * 70;
                    b = 10 + elevation * 80 + heightIntensity * 50;
                } else if(elevation < 0.6) {
                    const t = (elevation - 0.3) / 0.3;
                    r = 50 + t * 80 + heightIntensity * 70;
                    g = 60 + t * 80 + heightIntensity * 80;
                    b = 30 + t * 60 + heightIntensity * 90;
                } else {
                    const t = (elevation - 0.6) / 0.4;
                    r = 130 + t * 90 + heightIntensity * 35;
                    g = 140 + t * 90 + heightIntensity * 40;
                    b = 90 + t * 120 + heightIntensity * 85;
                }
                
                const isEveryFifth = layer.level % 5 === 0;
                const lineWidth = game.mapView === 'SIMPLIFIED' ? 2 : (isEveryFifth ? 2.5 : 1.2);
                
                ctx.strokeStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                ctx.lineWidth = lineWidth;
                
                ctx.beginPath();
                layer.verts.forEach((v, vi) => {
                    if(vi === 0) ctx.moveTo(h.x + v.x, h.y + v.y);
                    else ctx.lineTo(h.x + v.x, h.y + v.y);
                });
                ctx.closePath();
                ctx.stroke();
            });
        }
    });
    
    ctx.strokeStyle = "#f44";
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 8]);
    
    let spawnZone = {x: 0, y: 0, w: 0, h: 0};
    if(game.spawnDir === 'NORTH') {
        spawnZone = {x: 0, y: 0, w: CONFIG.WIDTH, h: 180};
    } else if(game.spawnDir === 'SOUTH') {
        spawnZone = {x: 0, y: CONFIG.HEIGHT - 180, w: CONFIG.WIDTH, h: 180};
    } else if(game.spawnDir === 'EAST') {
        spawnZone = {x: CONFIG.WIDTH - 180, y: 0, w: 180, h: CONFIG.HEIGHT};
    } else {
        spawnZone = {x: 0, y: 0, w: 180, h: CONFIG.HEIGHT};
    }
    
    ctx.strokeRect(spawnZone.x, spawnZone.y, spawnZone.w, spawnZone.h);
    ctx.setLineDash([]);
    
    if (game.debugPathfinding && game.flowField.land) {
        const ff = game.flowField.land;
        const spacing = CONFIG.GRID_SIZE;
        
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
        ctx.fillStyle = 'rgba(255, 0, 255, 0.6)';
        ctx.lineWidth = 2;
        
        for (let row = 0; row < ff.gridRows; row += 2) {
            for (let col = 0; col < ff.gridCols; col += 2) {
                const x = col * spacing + spacing / 2;
                const y = row * spacing + spacing / 2;
                
                const dir = ff.directions[row][col];
                if (!dir) continue;
                
                const cost = ff.costs[row][col];
                if (cost === Infinity) continue;
                
                const arrowLen = 20;
                const dx = dir.dx * arrowLen;
                const dy = dir.dy * arrowLen;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + dx, y + dy);
                ctx.stroke();
                
                const angle = Math.atan2(dy, dx);
                ctx.beginPath();
                ctx.moveTo(x + dx, y + dy);
                ctx.lineTo(x + dx - 8 * Math.cos(angle - 0.3), y + dy - 8 * Math.sin(angle - 0.3));
                ctx.lineTo(x + dx - 8 * Math.cos(angle + 0.3), y + dy - 8 * Math.sin(angle + 0.3));
                ctx.closePath();
                ctx.fill();
            }
        }
    }
}

function renderPlayerUnit() {
    // Check terrain cost and show visual indicator if slowed
    const terrainCost = getTerrainCost(game.player.x, game.player.y, 'LAND', 12);
    
    // Red ring when significantly slowed
    if (terrainCost > 1.5) {
        ctx.strokeStyle = "rgba(255, 50, 50, 0.6)";
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(game.player.x, game.player.y, 20, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(game.player.x, game.player.y-12); ctx.lineTo(game.player.x+12, game.player.y); ctx.lineTo(game.player.x, game.player.y+12); ctx.lineTo(game.player.x-12, game.player.y); ctx.closePath(); ctx.stroke();
    ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(game.player.x, game.player.y, 2, 0, Math.PI*2); ctx.fill();
    const a = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
    ctx.setLineDash([2, 4]); ctx.beginPath(); ctx.moveTo(game.player.x, game.player.y); ctx.lineTo(game.player.x+Math.cos(a)*40, game.player.y+Math.sin(a)*40); ctx.stroke(); ctx.setLineDash([]);
    
    // Secondary weapon range indicator when right mouse is down
    if (game.mouse.rightDown && game.mode === 'COMBAT') {
        const weapon = CONFIG.WEAPONS_SECONDARY[game.player.secondaryWeapon];
        const now = Date.now();
        const ready = (now - game.player.lastGrenade) >= weapon.cooldown;
        
        // Draw max range circle
        ctx.strokeStyle = ready ? "rgba(100, 255, 100, 0.3)" : "rgba(255, 100, 100, 0.3)";
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.arc(game.player.x, game.player.y, weapon.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw target point
        const dx = game.mouse.x - game.player.x;
        const dy = game.mouse.y - game.player.y;
        const dist = Math.hypot(dx, dy);
        
        let targetX = game.mouse.x;
        let targetY = game.mouse.y;
        if (dist > weapon.range) {
            const angle = Math.atan2(dy, dx);
            targetX = game.player.x + Math.cos(angle) * weapon.range;
            targetY = game.player.y + Math.sin(angle) * weapon.range;
        }
        
        // Draw blast radius at target
        ctx.strokeStyle = ready ? "rgba(255, 150, 0, 0.5)" : "rgba(255, 100, 100, 0.4)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(targetX, targetY, weapon.blastRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Crosshair at target
        ctx.strokeStyle = ready ? "#4f4" : "#f44";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(targetX - 10, targetY);
        ctx.lineTo(targetX + 10, targetY);
        ctx.moveTo(targetX, targetY - 10);
        ctx.lineTo(targetX, targetY + 10);
        ctx.stroke();
    }
}

function playerShoot() {
    const now = Date.now();
    const weapon = CONFIG.WEAPONS_PRIMARY[game.player.primaryWeapon];
    const rof = weapon.rof / (1 + (game.player.rofLv-1)*0.3);
    
    if (now - game.player.lastShot < rof) return;
    
    const baseAngle = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
    const dmg = weapon.dmg * (1 + (game.player.dmgLv-1)*0.5);
    
    if (game.player.primaryWeapon === 'SHOTGUN') {
        // Shotgun - multiple pellets with spread
        for (let i = 0; i < weapon.pellets; i++) {
            const spread = (Math.random() - 0.5) * weapon.spread;
            const angle = baseAngle + spread;
            game.projectiles.push({ 
                x: game.player.x, 
                y: game.player.y, 
                vx: Math.cos(angle) * weapon.velocity, 
                vy: Math.sin(angle) * weapon.velocity, 
                dmg,
                knockback: weapon.knockback,
                type: 'shotgun'
            });
        }
    } else if (game.player.primaryWeapon === 'MINIGUN') {
        // Minigun - single shot with spread
        const spread = (Math.random() - 0.5) * weapon.spread;
        const angle = baseAngle + spread;
        game.projectiles.push({ 
            x: game.player.x, 
            y: game.player.y, 
            vx: Math.cos(angle) * weapon.velocity, 
            vy: Math.sin(angle) * weapon.velocity, 
            dmg,
            type: 'minigun'
        });
    } else if (game.player.primaryWeapon === 'FLAMETHROWER') {
        // Flamethrower - continuous cone damage (no projectile, instant hit)
        game.enemies.forEach(e => {
            const dist = Math.hypot(e.x - game.player.x, e.y - game.player.y);
            if (dist < weapon.range) {
                // Check if in cone
                const angleToEnemy = Math.atan2(e.y - game.player.y, e.x - game.player.x);
                const angleDiff = Math.abs(angleToEnemy - baseAngle);
                const coneAngle = 0.4; // ~23 degrees each side
                
                if (angleDiff < coneAngle || angleDiff > Math.PI * 2 - coneAngle) {
                    e.hp -= dmg;
                    e.hitF = 2;
                }
            }
        });
        
        // Visual effect
        ctx.save();
        ctx.globalAlpha = 0.6;
        const gradient = ctx.createRadialGradient(
            game.player.x, game.player.y, 0,
            game.player.x + Math.cos(baseAngle) * weapon.range, 
            game.player.y + Math.sin(baseAngle) * weapon.range, 
            weapon.range * 0.5
        );
        gradient.addColorStop(0, 'rgba(255,150,0,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,50,0,0.4)');
        gradient.addColorStop(1, 'rgba(255,0,0,0)');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.moveTo(game.player.x, game.player.y);
        ctx.arc(game.player.x, game.player.y, weapon.range, baseAngle - 0.4, baseAngle + 0.4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
    } else if (game.player.primaryWeapon === 'RAILGUN') {
        // Railgun - piercing shot
        game.projectiles.push({ 
            x: game.player.x, 
            y: game.player.y, 
            vx: Math.cos(baseAngle) * weapon.velocity, 
            vy: Math.sin(baseAngle) * weapon.velocity, 
            dmg,
            type: 'railgun',
            piercing: true,
            hitEnemies: [] // Track which enemies were hit
        });
        
        // Visual effect
        ctx.strokeStyle = "rgba(0,255,255,0.9)";
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#0ff";
        ctx.beginPath();
        ctx.moveTo(game.player.x, game.player.y);
        ctx.lineTo(
            game.player.x + Math.cos(baseAngle) * 2000,
            game.player.y + Math.sin(baseAngle) * 2000
        );
        ctx.stroke();
        ctx.shadowBlur = 0;
        
    } else if (game.player.primaryWeapon === 'SNIPER') {
        // Sniper - high damage precise shot
        game.projectiles.push({ 
            x: game.player.x, 
            y: game.player.y, 
            vx: Math.cos(baseAngle) * weapon.velocity, 
            vy: Math.sin(baseAngle) * weapon.velocity, 
            dmg,
            type: 'sniper'
        });
    } else {
        // Rifle - precise single shot
        game.projectiles.push({ 
            x: game.player.x, 
            y: game.player.y, 
            vx: Math.cos(baseAngle) * weapon.velocity, 
            vy: Math.sin(baseAngle) * weapon.velocity, 
            dmg,
            type: 'rifle'
        });
    }
    
    game.player.lastShot = now;
}

function throwGrenade() {
    const now = Date.now();
    const weapon = CONFIG.WEAPONS_SECONDARY[game.player.secondaryWeapon];
    
    if (now - game.player.lastGrenade < weapon.cooldown) return;
    
    const dx = game.mouse.x - game.player.x;
    const dy = game.mouse.y - game.player.y;
    const dist = Math.hypot(dx, dy);
    
    // Clamp to max range
    let targetX = game.mouse.x;
    let targetY = game.mouse.y;
    if (dist > weapon.range) {
        const angle = Math.atan2(dy, dx);
        targetX = game.player.x + Math.cos(angle) * weapon.range;
        targetY = game.player.y + Math.sin(angle) * weapon.range;
    }
    
    if (game.player.secondaryWeapon === 'ROCKET') {
        // Rocket - direct projectile
        const angle = Math.atan2(targetY - game.player.y, targetX - game.player.x);
        game.rockets.push({
            x: game.player.x,
            y: game.player.y,
            vx: Math.cos(angle) * weapon.velocity,
            vy: Math.sin(angle) * weapon.velocity,
            damage: weapon.damage,
            blastRadius: weapon.blastRadius,
            trail: []
        });
    } else {
        // Grenade-based weapons (arc trajectory)
        const actualDist = Math.hypot(targetX - game.player.x, targetY - game.player.y);
        const travelTime = actualDist / 8;
        
        game.grenades.push({
            x: game.player.x,
            y: game.player.y,
            targetX,
            targetY,
            startX: game.player.x,
            startY: game.player.y,
            progress: 0,
            speed: 1 / travelTime,
            damage: weapon.damage,
            blastRadius: weapon.blastRadius,
            weaponType: game.player.secondaryWeapon
        });
    }
    
    game.player.lastGrenade = now;
}

function renderEntities() {
    game.entities.forEach(ent => {
        ctx.strokeStyle = ent.color; ctx.lineWidth = 2;
        if (ent.type === 'core') ctx.strokeRect(ent.x-15, ent.y-15, 30, 30);
        else if (ent.type === 'wall') ctx.strokeRect(ent.x-10, ent.y-10, 20, 20);
        else { ctx.beginPath(); ctx.arc(ent.x, ent.y, 10, 0, Math.PI*2); ctx.stroke(); }
        ctx.fillStyle = "#20ff20";
        ctx.fillRect(ent.x-12, ent.y+18, (ent.curHP/ent.hp)*24, 3);
    });
}

function handleInput() {
    if (game.mode === 'BASE' && game.selected) {
        const gx = Math.floor((game.mouse.x - 150) / 50), gy = Math.floor((game.mouse.y - 150) / 50);
        if(gx>=0 && gx<12 && gy>=0 && gy<12) {
            game.buildings.push({ gx, gy, cfg: CONFIG.BUILDINGS[game.selected] });
            game.money -= CONFIG.BUILDINGS[game.selected].cost; updateStatsUI();
        }
    } else if (game.mode === 'PREP' && game.selected) {
        const cfg = CONFIG.DEFENSE[game.selected];
        if (cfg.type === 'core' && game.corePlaced) return;
        if (game.money >= cfg.cost) {
            game.entities.push({ ...cfg, x: game.mouse.x, y: game.mouse.y, curHP: cfg.hp, lastFire: 0 });
            if (cfg.type === 'core') { game.corePlaced = true; game.player.x = game.mouse.x; game.player.y = game.mouse.y; }
            else game.money -= cfg.cost;
            updateStatsUI();
        }
    }
}

function renderProjectiles() {
    game.projectiles.forEach((p, i) => {
        p.x += p.vx; 
        p.y += p.vy;
        
        // Visual based on type
        if (p.type === 'minigun') {
            ctx.fillStyle = "#ffa500";
            ctx.fillRect(p.x - 1, p.y - 1, 3, 3);
        } else if (p.type === 'shotgun') {
            ctx.fillStyle = "#ff4444";
            ctx.fillRect(p.x - 1, p.y - 1, 4, 4);
        } else if (p.type === 'sniper') {
            ctx.fillStyle = "#ff0";
            ctx.shadowBlur = 5;
            ctx.shadowColor = "#ff0";
            ctx.fillRect(p.x - 2, p.y - 2, 5, 5);
            ctx.shadowBlur = 0;
        } else if (p.type === 'railgun') {
            ctx.fillStyle = "#0ff";
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#0ff";
            ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
            ctx.shadowBlur = 0;
        } else {
            ctx.fillStyle = "#fff";
            ctx.fillRect(p.x, p.y, 3, 3);
        }
        
        // Piercing logic for railgun
        if (p.piercing) {
            p.hitEnemies = p.hitEnemies || [];
            game.enemies.forEach(e => {
                if (!p.hitEnemies.includes(e) && Math.hypot(e.x - p.x, e.y - p.y) < e.size) {
                    e.hp -= p.dmg;
                    e.hitF = 5;
                    p.hitEnemies.push(e);
                    
                    // Impact effect
                    ctx.fillStyle = "rgba(0,255,255,0.7)";
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size + 10, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        } else {
            // Normal hit detection
            const hit = game.enemies.find(e => Math.hypot(e.x - p.x, e.y - p.y) < e.size);
            if (hit) { 
                hit.hp -= p.dmg; 
                hit.hitF = 3;
                
                // Knockback for shotgun
                if (p.knockback) {
                    const angle = Math.atan2(p.vy, p.vx);
                    hit.x += Math.cos(angle) * p.knockback;
                    hit.y += Math.sin(angle) * p.knockback;
                }
                
                game.projectiles.splice(i, 1); 
            }
        }
        
        if (p.x < 0 || p.x > CONFIG.WIDTH || p.y < 0 || p.y > CONFIG.HEIGHT) game.projectiles.splice(i, 1);
    });
}

function renderGrenades() {
    game.grenades.forEach((g, i) => {
        // Update grenade position
        g.progress += g.speed;
        
        if (g.progress >= 1) {
            // Grenade landed - create explosion based on type
            if (g.weaponType === 'CLUSTER') {
                // Main explosion
                game.explosions.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: 0,
                    maxRadius: g.blastRadius,
                    damage: g.damage,
                    frame: 0,
                    maxFrames: 20,
                    hasDealtDamage: false
                });
                
                // Spawn cluster bomblets
                for (let c = 0; c < CONFIG.WEAPONS_SECONDARY.CLUSTER.clusters; c++) {
                    const angle = (c / CONFIG.WEAPONS_SECONDARY.CLUSTER.clusters) * Math.PI * 2;
                    const dist = 60 + Math.random() * 40;
                    game.explosions.push({
                        x: g.targetX + Math.cos(angle) * dist,
                        y: g.targetY + Math.sin(angle) * dist,
                        radius: 0,
                        maxRadius: g.blastRadius * 0.7,
                        damage: g.damage * 0.8,
                        frame: Math.floor(Math.random() * 5), // Stagger
                        maxFrames: 18,
                        hasDealtDamage: false
                    });
                }
            } else if (g.weaponType === 'INCENDIARY') {
                // Create burn zone
                const weapon = CONFIG.WEAPONS_SECONDARY.INCENDIARY;
                game.burnZones.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: g.blastRadius,
                    damage: weapon.burnDmg,
                    duration: weapon.burnTime,
                    frame: 0
                });
                
                // Initial blast
                game.explosions.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: 0,
                    maxRadius: g.blastRadius,
                    damage: g.damage,
                    frame: 0,
                    maxFrames: 25,
                    hasDealtDamage: false,
                    color: 'fire'
                });
            } else if (g.weaponType === 'POISON') {
                // Create poison cloud
                const weapon = CONFIG.WEAPONS_SECONDARY.POISON;
                game.poisonClouds.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: g.blastRadius,
                    damage: weapon.poisonDmg,
                    duration: weapon.poisonTime,
                    frame: 0
                });
                
                // Initial blast
                game.explosions.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: 0,
                    maxRadius: g.blastRadius,
                    damage: g.damage,
                    frame: 0,
                    maxFrames: 25,
                    hasDealtDamage: false,
                    color: 'poison'
                });
            } else if (g.weaponType === 'EMP') {
                // EMP blast - stuns enemies
                game.enemies.forEach(enemy => {
                    const dist = Math.hypot(enemy.x - g.targetX, enemy.y - g.targetY);
                    if (dist < g.blastRadius) {
                        enemy.stunned = true;
                        enemy.stunTimer = CONFIG.WEAPONS_SECONDARY.EMP.stunTime;
                        enemy.originalSpeed = enemy.speed;
                        enemy.speed = 0;
                    }
                });
                
                // EMP visual effect
                game.explosions.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: 0,
                    maxRadius: g.blastRadius,
                    damage: 0, // No damage
                    frame: 0,
                    maxFrames: 30,
                    hasDealtDamage: true, // Skip damage dealing
                    color: 'emp'
                });
            } else if (g.weaponType === 'BANANA') {
                // BANANA GRENADE - Worms style!
                const weapon = CONFIG.WEAPONS_SECONDARY.BANANA;
                
                // Main banana explosion
                game.explosions.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: 0,
                    maxRadius: g.blastRadius,
                    damage: g.damage,
                    frame: 0,
                    maxFrames: 20,
                    hasDealtDamage: false,
                    color: 'banana'
                });
                
                // Spawn 7 secondary bananas that arc outward
                for (let b = 0; b < weapon.bananas; b++) {
                    const angle = (b / weapon.bananas) * Math.PI * 2;
                    const dist = 120 + Math.random() * 80; // 120-200px distance
                    const targetX = g.targetX + Math.cos(angle) * dist;
                    const targetY = g.targetY + Math.sin(angle) * dist;
                    
                    // Create secondary banana grenades
                    game.grenades.push({
                        x: g.targetX,
                        y: g.targetY,
                        targetX: targetX,
                        targetY: targetY,
                        startX: g.targetX,
                        startY: g.targetY,
                        progress: 0,
                        speed: 0.03 + Math.random() * 0.02, // Varied speed
                        damage: g.damage * 0.5, // Half damage for secondary
                        blastRadius: g.blastRadius * 0.6, // Smaller radius
                        weaponType: 'BANANA_SECONDARY' // Special flag to prevent infinite recursion
                    });
                }
            } else if (g.weaponType === 'BANANA_SECONDARY') {
                // Secondary banana - just explode, no more splitting
                game.explosions.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: 0,
                    maxRadius: g.blastRadius,
                    damage: g.damage,
                    frame: 0,
                    maxFrames: 18,
                    hasDealtDamage: false,
                    color: 'banana'
                });
            } else {
                // Standard grenade
                game.explosions.push({
                    x: g.targetX,
                    y: g.targetY,
                    radius: 0,
                    maxRadius: g.blastRadius,
                    damage: g.damage,
                    frame: 0,
                    maxFrames: 20,
                    hasDealtDamage: false
                });
            }
            game.grenades.splice(i, 1);
            return;
        }
        
        // Arc trajectory
        g.x = g.startX + (g.targetX - g.startX) * g.progress;
        g.y = g.startY + (g.targetY - g.startY) * g.progress;
        
        // Arc height (parabola)
        const arcHeight = 80;
        const heightOffset = -arcHeight * Math.sin(g.progress * Math.PI);
        
        // Draw grenade with color based on type
        let grenadeColor = "#4f4";
        if (g.weaponType === 'CLUSTER') grenadeColor = "#88f";
        else if (g.weaponType === 'INCENDIARY') grenadeColor = "#f84";
        else if (g.weaponType === 'POISON') grenadeColor = "#8f4";
        else if (g.weaponType === 'EMP') grenadeColor = "#4af";
        else if (g.weaponType === 'BANANA' || g.weaponType === 'BANANA_SECONDARY') grenadeColor = "#ff0";
        
        ctx.fillStyle = grenadeColor;
        ctx.strokeStyle = grenadeColor === "#4f4" ? "#2a2" : grenadeColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(g.x, g.y + heightOffset, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(g.x, g.y, 4, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    });
}

function renderRockets() {
    game.rockets.forEach((r, i) => {
        // Update position
        r.x += r.vx;
        r.y += r.vy;
        
        // Add to trail
        r.trail.push({x: r.x, y: r.y});
        if (r.trail.length > 15) r.trail.shift();
        
        // Draw trail
        ctx.strokeStyle = "rgba(255, 150, 50, 0.6)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        r.trail.forEach((t, ti) => {
            if (ti === 0) ctx.moveTo(t.x, t.y);
            else ctx.lineTo(t.x, t.y);
        });
        ctx.stroke();
        
        // Draw rocket
        const angle = Math.atan2(r.vy, r.vx);
        ctx.save();
        ctx.translate(r.x, r.y);
        ctx.rotate(angle);
        
        // Rocket body
        ctx.fillStyle = "#888";
        ctx.fillRect(-8, -3, 16, 6);
        
        // Nose cone
        ctx.fillStyle = "#f44";
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(14, -3);
        ctx.lineTo(14, 3);
        ctx.closePath();
        ctx.fill();
        
        // Fins
        ctx.fillStyle = "#666";
        ctx.fillRect(-8, -5, 4, 2);
        ctx.fillRect(-8, 3, 4, 2);
        
        ctx.restore();
        
        // Check collision
        const hit = game.enemies.find(e => Math.hypot(e.x - r.x, e.y - r.y) < e.size + 10);
        const outOfBounds = r.x < 0 || r.x > CONFIG.WIDTH || r.y < 0 || r.y > CONFIG.HEIGHT;
        
        if (hit || outOfBounds) {
            // Explode
            game.explosions.push({
                x: r.x,
                y: r.y,
                radius: 0,
                maxRadius: r.blastRadius,
                damage: r.damage,
                frame: 0,
                maxFrames: 25,
                hasDealtDamage: false,
                color: 'rocket'
            });
            game.rockets.splice(i, 1);
        }
    });
}

function renderBurnZones() {
    game.burnZones.forEach((z, i) => {
        z.frame++;
        
        // Apply burn damage to enemies in zone
        if (z.frame % 10 === 0) { // Every 10 frames
            game.enemies.forEach(enemy => {
                const dist = Math.hypot(enemy.x - z.x, enemy.y - z.y);
                if (dist < z.radius) {
                    enemy.hp -= z.damage;
                    enemy.hitF = 2;
                }
            });
        }
        
        // Render fire particles
        const alpha = 1 - (z.frame / z.duration);
        const particleCount = 30;
        
        for (let p = 0; p < particleCount; p++) {
            const angle = (p / particleCount) * Math.PI * 2 + z.frame * 0.05;
            const dist = Math.random() * z.radius;
            const x = z.x + Math.cos(angle) * dist;
            const y = z.y + Math.sin(angle) * dist;
            
            const flicker = 0.5 + Math.random() * 0.5;
            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha * flicker * 0.4})`;
            ctx.beginPath();
            ctx.arc(x, y, 3 + Math.random() * 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Border glow
        ctx.strokeStyle = `rgba(255, 80, 0, ${alpha * 0.3})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        if (z.frame >= z.duration) {
            game.burnZones.splice(i, 1);
        }
    });
}

function renderPoisonClouds() {
    game.poisonClouds.forEach((z, i) => {
        z.frame++;
        
        // Apply poison damage to enemies in cloud
        if (z.frame % 10 === 0) { // Every 10 frames
            game.enemies.forEach(enemy => {
                const dist = Math.hypot(enemy.x - z.x, enemy.y - z.y);
                if (dist < z.radius) {
                    enemy.hp -= z.damage;
                    enemy.hitF = 2;
                }
            });
        }
        
        // Render poison cloud particles
        const alpha = 1 - (z.frame / z.duration);
        const particleCount = 40;
        
        for (let p = 0; p < particleCount; p++) {
            const angle = (p / particleCount) * Math.PI * 2 + z.frame * 0.03;
            const dist = Math.random() * z.radius;
            const x = z.x + Math.cos(angle) * dist;
            const y = z.y + Math.sin(angle) * dist - Math.sin(z.frame * 0.05 + p) * 5; // Floating effect
            
            const flicker = 0.5 + Math.random() * 0.5;
            ctx.fillStyle = `rgba(${50 + Math.random() * 100}, 255, ${50 + Math.random() * 50}, ${alpha * flicker * 0.3})`;
            ctx.beginPath();
            ctx.arc(x, y, 4 + Math.random() * 5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Border glow (green)
        ctx.strokeStyle = `rgba(100, 255, 100, ${alpha * 0.4})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        if (z.frame >= z.duration) {
            game.poisonClouds.splice(i, 1);
        }
    });
}

function renderTowerGrenades() {
    game.towerGrenades.forEach((g, i) => {
        g.progress += g.speed;
        
        if (g.progress >= 1) {
            // Create explosion
            game.explosions.push({
                x: g.targetX,
                y: g.targetY,
                radius: 0,
                maxRadius: g.blastRadius,
                damage: g.damage,
                frame: 0,
                maxFrames: 20,
                hasDealtDamage: false
            });
            game.towerGrenades.splice(i, 1);
            return;
        }
        
        // Arc trajectory
        g.x = g.startX + (g.targetX - g.startX) * g.progress;
        g.y = g.startY + (g.targetY - g.startY) * g.progress;
        
        const arcHeight = 60;
        const heightOffset = -arcHeight * Math.sin(g.progress * Math.PI);
        
        // Draw grenade
        ctx.fillStyle = "#9f9";
        ctx.strokeStyle = "#5a5";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(g.x, g.y + heightOffset, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(g.x, g.y, 3, 1.5, 0, 0, Math.PI * 2);
        ctx.fill();
    });
}

function renderExplosions() {
    game.explosions.forEach((e, i) => {
        e.frame++;
        
        // Expanding blast radius
        if (e.frame < e.maxFrames / 2) {
            e.radius = (e.frame / (e.maxFrames / 2)) * e.maxRadius;
        } else {
            e.radius = e.maxRadius * (1 - (e.frame - e.maxFrames / 2) / (e.maxFrames / 2));
        }
        
        // Deal damage once at peak
        if (e.frame === Math.floor(e.maxFrames / 2) && !e.hasDealtDamage) {
            game.enemies.forEach(enemy => {
                const dist = Math.hypot(enemy.x - e.x, enemy.y - e.y);
                if (dist < e.maxRadius) {
                    // Damage falloff based on distance
                    const falloff = 1 - (dist / e.maxRadius);
                    const damage = e.damage * falloff;
                    enemy.hp -= damage;
                    enemy.hitF = 5;
                }
            });
            e.hasDealtDamage = true;
        }
        
        // Colors based on weapon type
        let outerColor, innerColor, coreColor;
        if (e.color === 'fire') {
            outerColor = [255, 80, 0];
            innerColor = [255, 150, 0];
            coreColor = [255, 220, 100];
        } else if (e.color === 'rocket') {
            outerColor = [255, 120, 0];
            innerColor = [255, 200, 50];
            coreColor = [255, 255, 220];
        } else if (e.color === 'poison') {
            outerColor = [100, 255, 100];
            innerColor = [150, 255, 150];
            coreColor = [200, 255, 200];
        } else if (e.color === 'emp') {
            outerColor = [0, 150, 255];
            innerColor = [100, 200, 255];
            coreColor = [200, 230, 255];
        } else if (e.color === 'banana') {
            outerColor = [255, 220, 0];
            innerColor = [255, 240, 100];
            coreColor = [255, 255, 200];
        } else {
            outerColor = [255, 100, 0];
            innerColor = [255, 200, 0];
            coreColor = [255, 255, 200];
        }
        
        const alpha = 1 - (e.frame / e.maxFrames);
        
        // Outer ring
        ctx.strokeStyle = `rgba(${outerColor[0]}, ${outerColor[1]}, ${outerColor[2]}, ${alpha * 0.8})`;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner flash
        ctx.fillStyle = `rgba(${innerColor[0]}, ${innerColor[1]}, ${innerColor[2]}, ${alpha * 0.5})`;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        // Core
        ctx.fillStyle = `rgba(${coreColor[0]}, ${coreColor[1]}, ${coreColor[2]}, ${alpha})`;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Remove finished explosions
        if (e.frame >= e.maxFrames) {
            game.explosions.splice(i, 1);
        }
    });
}

function renderBaseGrid() {
    ctx.strokeStyle = "rgba(32, 255, 32, 0.1)";
    for(let i=0; i<=12; i++) {
        ctx.beginPath(); ctx.moveTo(150+i*50, 150); ctx.lineTo(150+i*50, 750); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(150, 150+i*50); ctx.lineTo(750, 150+i*50); ctx.stroke();
    }
    game.buildings.forEach(b => { ctx.fillStyle = b.cfg.color; ctx.fillRect(150+b.gx*50+5, 150+b.gy*50+5, 40, 40); });
}

function renderGhost() {
    const cfg = CONFIG.DEFENSE[game.selected];
    ctx.strokeStyle = "rgba(255,255,255,0.3)";
    if (cfg.range) { ctx.beginPath(); ctx.arc(game.mouse.x, game.mouse.y, cfg.range, 0, Math.PI*2); ctx.stroke(); }
    ctx.strokeRect(game.mouse.x-10, game.mouse.y-10, 20, 20);
}

function updateStatsUI() {
    document.getElementById('ui-money').innerText = `$${Math.floor(game.money)}`;
    document.getElementById('ui-hp').innerText = `${Math.max(0, Math.ceil((game.hp/6000)*100))}%`;
    document.getElementById('p-spd').innerText = (1 + (game.player.spdLv-1)*0.2).toFixed(1);
    document.getElementById('p-rof').innerText = (1 + (game.player.rofLv-1)*0.3).toFixed(1);
    document.getElementById('p-dmg').innerText = (1 + (game.player.dmgLv-1)*0.5).toFixed(1);
    
    // Update weapon names
    const primName = document.getElementById('weapon-primary');
    const secName = document.getElementById('weapon-secondary');
    if (primName) primName.innerText = CONFIG.WEAPONS_PRIMARY[game.player.primaryWeapon].name;
    if (secName) secName.innerText = CONFIG.WEAPONS_SECONDARY[game.player.secondaryWeapon].name;
}

function updateBuildMenu() {
    const menu = document.getElementById('buildMenu'); menu.innerHTML = "";
    const list = (game.mode === 'BASE') ? CONFIG.BUILDINGS : CONFIG.DEFENSE;
    
    if(game.mode === 'BASE') {
        // === WEAPON SELECTION ===
        const weaponDiv = document.createElement('div');
        weaponDiv.style.marginBottom = '20px';
        weaponDiv.innerHTML = '<h3 style="margin: 0 0 10px 0; font-size: 1.4em; color: #4af;">⚔ ARMORY</h3>';
        
        // Primary weapons
        weaponDiv.innerHTML += '<div style="font-size: 1.1em; margin: 10px 0 5px 0; color: #8f8;">PRIMARY (LMB):</div>';
        for (let key in CONFIG.WEAPONS_PRIMARY) {
            const wpn = CONFIG.WEAPONS_PRIMARY[key];
            const owned = game.player.ownedWeapons[key];
            const selected = game.player.primaryWeapon === key;
            
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.style.fontSize = '0.9em';
            btn.style.padding = '8px';
            btn.style.background = selected ? '#0a4' : (owned ? '#222' : '#400');
            btn.style.borderColor = selected ? '#0f0' : (owned ? '#4af' : '#844');
            btn.style.color = selected ? '#fff' : (owned ? '#4af' : '#844');
            btn.style.fontWeight = selected ? 'bold' : 'normal';
            
            const costStr = owned ? '' : ` [$${wpn.cost}]`;
            btn.innerHTML = `${wpn.name}${costStr}<br><span style="font-size: 0.8em; color: #888;">${wpn.desc}</span>`;
            
            btn.onclick = () => {
                if (!owned) {
                    if (game.money >= wpn.cost) {
                        game.money -= wpn.cost;
                        game.player.ownedWeapons[key] = true;
                        game.player.primaryWeapon = key;
                        console.log(`[PRIMARY] Purchased & Selected: ${key}`);
                        logTerminal(`EQUIPPED PRIMARY: ${wpn.name}`);
                        updateBuildMenu();
                        updateStatsUI();
                    } else {
                        logTerminal(`INSUFFICIENT FUNDS: ${wpn.name}`);
                    }
                } else {
                    game.player.primaryWeapon = key;
                    console.log(`[PRIMARY] Selected: ${key}`);
                    logTerminal(`EQUIPPED PRIMARY: ${wpn.name}`);
                    updateBuildMenu();
                    updateStatsUI();
                }
            };
            
            weaponDiv.appendChild(btn);
        }
        
        // Secondary weapons
        weaponDiv.innerHTML += '<div style="font-size: 1.1em; margin: 15px 0 5px 0; color: #8f8;">SECONDARY (RMB):</div>';
        for (let key in CONFIG.WEAPONS_SECONDARY) {
            const wpn = CONFIG.WEAPONS_SECONDARY[key];
            const owned = game.player.ownedWeapons[key];
            const selected = game.player.secondaryWeapon === key;
            
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.style.fontSize = '0.9em';
            btn.style.padding = '8px';
            btn.style.background = selected ? '#0a4' : (owned ? '#222' : '#400');
            btn.style.borderColor = selected ? '#0f0' : (owned ? '#f84' : '#844');
            btn.style.color = selected ? '#fff' : (owned ? '#f84' : '#844');
            btn.style.fontWeight = selected ? 'bold' : 'normal';
            
            const costStr = owned ? '' : ` [$${wpn.cost}]`;
            btn.innerHTML = `${wpn.name}${costStr}<br><span style="font-size: 0.8em; color: #888;">${wpn.desc}</span>`;
            
            btn.onclick = () => {
                if (!owned) {
                    if (game.money >= wpn.cost) {
                        game.money -= wpn.cost;
                        game.player.ownedWeapons[key] = true;
                        game.player.secondaryWeapon = key;
                        console.log(`[SECONDARY] Purchased & Selected: ${key}`);
                        logTerminal(`EQUIPPED SECONDARY: ${wpn.name}`);
                        updateBuildMenu();
                        updateStatsUI();
                    } else {
                        logTerminal(`INSUFFICIENT FUNDS: ${wpn.name}`);
                    }
                } else {
                    game.player.secondaryWeapon = key;
                    console.log(`[SECONDARY] Selected: ${key}`);
                    logTerminal(`EQUIPPED SECONDARY: ${wpn.name}`);
                    updateBuildMenu();
                    updateStatsUI();
                }
            };
            
            weaponDiv.appendChild(btn);
        }
        
        menu.appendChild(weaponDiv);
        
        const hr1 = document.createElement('div');
        hr1.style.borderTop = '2px solid #444';
        hr1.style.margin = '15px 0';
        menu.appendChild(hr1);
        
        // === MAP SELECTION ===
        const mapSelectorDiv = document.createElement('div');
        mapSelectorDiv.style.marginBottom = '15px';
        mapSelectorDiv.innerHTML = '<h3 style="margin: 0 0 8px 0; font-size: 1.3em;">🗺 BATTLEFIELD:</h3>';
        
        const mapSelect = document.createElement('select');
        mapSelect.id = 'map-selector';
        
        const randomOption = document.createElement('option');
        randomOption.value = '';
        randomOption.innerText = '[ RANDOM MAP ]';
        mapSelect.appendChild(randomOption);
        
        const maps = JSON.parse(localStorage.getItem('outpost_maps') || '{}');
        for(let name in maps) {
            const option = document.createElement('option');
            option.value = name;
            option.innerText = name;
            if(game.selectedCustomMap === name) option.selected = true;
            mapSelect.appendChild(option);
        }
        
        mapSelect.onchange = (e) => {
            game.selectedCustomMap = e.target.value || null;
            logTerminal(game.selectedCustomMap ? `Selected: ${game.selectedCustomMap}` : 'Random map');
        };
        
        mapSelectorDiv.appendChild(mapSelect);
        menu.appendChild(mapSelectorDiv);
        
        const hr2 = document.createElement('div');
        hr2.style.borderTop = '1px solid #444';
        hr2.style.margin = '15px 0';
        menu.appendChild(hr2);
        
        // === UPGRADES ===
        menu.innerHTML += '<div style="font-size: 1.1em; margin: 10px 0 5px 0; color: #8f8;">UNIT UPGRADES:</div>';
        const row = document.createElement('div'); row.className = 'upgrade-row';
        ['SPD', 'ROF', 'DMG'].forEach(s => {
            const b = document.createElement('button'); b.className = 'btn'; b.style.fontSize = '0.7em';
            const cost = game.player[s.toLowerCase()+'Lv']*300;
            b.innerText = `${s} LV${game.player[s.toLowerCase()+'Lv']} [$${cost}]`;
            b.onclick = () => { 
                if(game.money >= cost) { 
                    game.money -= cost; 
                    game.player[s.toLowerCase()+'Lv']++; 
                    updateStatsUI(); 
                    updateBuildMenu();
                    logTerminal(`UPGRADED: ${s}`);
                }
            };
            row.appendChild(b);
        });
        menu.appendChild(row);
    } else {
        // PREP/COMBAT mode - show defense structures
        for(let k in list) {
            const item = list[k];
            const btn = document.createElement('button');
            btn.className = 'btn' + (game.selected === k ? ' active' : '');
            btn.innerHTML = `${item.name} <span style="float:right">$${item.cost}</span>`;
            btn.onclick = () => { game.selected = k; updateBuildMenu(); };
            menu.appendChild(btn);
        }
    }
    
    if(game.mode === 'PREP' || game.mode === 'COMBAT') {
        const viewBtn = document.createElement('button');
        viewBtn.className = 'btn';
        viewBtn.style.marginTop = '15px';
        viewBtn.style.background = '#333';
        viewBtn.style.borderColor = '#888';
        viewBtn.innerHTML = `MAP VIEW: ${game.mapView}`;
        viewBtn.onclick = () => {
            game.mapView = game.mapView === 'DETAILED' ? 'SIMPLIFIED' : 'DETAILED';
            updateBuildMenu();
        };
        menu.appendChild(viewBtn);
        
        const debugBtn = document.createElement('button');
        debugBtn.className = 'btn';
        debugBtn.style.background = game.debugPathfinding ? '#083308' : '#222';
        debugBtn.style.borderColor = '#4af';
        debugBtn.style.color = '#4af';
        debugBtn.innerHTML = `DEBUG: ${game.debugPathfinding ? 'ON' : 'OFF'}`;
        debugBtn.onclick = () => {
            game.debugPathfinding = !game.debugPathfinding;
            updateBuildMenu();
            logTerminal(game.debugPathfinding ? 'DEBUG: Flow field visible' : 'DEBUG: Flow field hidden');
        };
        menu.appendChild(debugBtn);
    }
}

function logTerminal(t) { 
    const term = document.getElementById('terminal');
    term.innerHTML += `> ${t}<br>`; term.scrollTop = term.scrollHeight;
}

window.handleAction = handleAction;
window.throwGrenade = throwGrenade;

init();
</script>
</body>
</html>

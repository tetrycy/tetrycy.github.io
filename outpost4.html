<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>OUTPOST '95: MOUNTAINS RESTORED</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root { --f-green: #20ff20; --f-bg: #050805; --panel: #1a1c1a; --f-red: #ff1111; --f-blue: #00ffff; --f-purple: #cc33ff; --f-hp: #ffff00; }
        body { margin: 0; background: #000; color: var(--f-green); font-family: VT323, monospace; display: flex; height: 100vh; overflow: hidden; font-size: 18px; user-select: none; }
        #viewport { flex-grow: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; padding: 20px; }
        canvas { border: 2px solid var(--f-green); background: var(--f-bg); cursor: crosshair; image-rendering: pixelated; max-width: 100%; max-height: 100%; object-fit: contain; box-shadow: 0 0 20px rgba(32, 255, 32, 0.1); }
        #sidebar { width: 380px; background: var(--panel); border-left: 4px ridge #444; display: flex; flex-direction: column; padding: 20px; z-index: 10; }
        .screen { background: #000; border: 1px solid var(--f-green); padding: 15px; margin-bottom: 12px; box-shadow: inset 0 0 15px rgba(0,255,0,0.2); }
        .btn { background: #222; color: var(--f-green); border: 2px solid var(--f-green); padding: 12px; margin: 5px 0; cursor: pointer; font-family: VT323; font-size: 1.3em; text-transform: uppercase; width: 100%; text-align: left; }
        .btn:hover:not(:disabled) { background: var(--f-green); color: #000; }
        .btn.active { background: #083308; box-shadow: 0 0 10px var(--f-green); }
        .stat { display: flex; justify-content: space-between; font-size: 1.5em; }
        #terminal { font-size: 1em; height: 140px; overflow-y: auto; color: #8f8; border: 1px solid #1a331a; padding: 8px; background: #020502; }
    </style>
</head>
<body>

<div id="viewport">
    <canvas id="gameCanvas" width="1200" height="900"></canvas>
</div>

<div id="sidebar">
    <h2 style="text-align:center; border-bottom:2px solid var(--f-green); margin:0 0 10px 0;">STRAT-COM INTERFACE</h2>
    <div class="screen">
        <div class="stat"><span>CREDITS:</span> <span id="ui-money">$800</span></div>
        <div class="stat"><span>HQ HULL:</span> <span id="ui-hp">100%</span></div>
    </div>
    <div class="screen" id="terminal">> SYSTEM ONLINE...</div>
    <div id="buildMenu" style="flex-grow: 1; overflow-y: auto;"></div>
    <button class="btn" id="actionBtn" style="background:#400; border-color:#f44; color:#f44; font-weight:bold;" onclick="handleAction()">EXECUTE COMBAT</button>
</div>

<script>
const CONFIG = {
    WIDTH: 1200, HEIGHT: 900, SCALE: 0.5, BASE_OFF: { x: 300, y: 150 }, CELL: 50, GRID: 12, PATH_GRID: 40,
    DEFENSE: {
        CORE: { name: "HQ BUNKER", cost: 0, hp: 6000, type: 'core', color: '#0ff', size: 22 },
        WALL: { name: "HEAVY WALL", cost: 20, hp: 1500, type: 'wall', color: '#666', size: 16 },
        SENTRY: { name: "AUTO-TURRET", cost: 180, range: 250, dmg: 15, rof: 500, hp: 600, type: 'tower', color: '#ff0', size: 14 },
        BATTERY: { name: "LR BATTERY", cost: 400, range: 420, dmg: 200, rof: 2800, hp: 1000, type: 'tower', color: '#f80', size: 18 }
    },
    BUILDINGS: {
        SOLAR: { name: "SOLAR ARRAY", cost: 150, pwr: 50, color: "#AA0" },
        FARM: { name: "BIO-FARM", cost: 200, pwr: -10, color: "#0A0" },
        MUNITION: { name: "MUNITION FAB", cost: 450, pwr: -50, color: "#A00" }
    }
};

let game = {
    money: 800, hp: 6000, wave: 0, mode: 'BASE',
    buildings: [], entities: [], enemies: [], projectiles: [],
    terrain: { hills: [], lakes: [], forests: [] },
    flowField: [], selected: null, corePlaced: false,
    mouse: { x:0, y:0, down: false }, keys: {},
    player: { x: 600, y: 450, hp: 600, maxHp: 600, spd: 4.5, lastShot: 0 },
    spawnDir: 'NORTH'
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function init() {
    window.addEventListener('keydown', e => game.keys[e.code] = true);
    window.addEventListener('keyup', e => game.keys[e.code] = false);
    canvas.addEventListener('mousemove', e => {
        const r = canvas.getBoundingClientRect();
        game.mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
        game.mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
    });
    canvas.addEventListener('mousedown', () => game.mouse.down = true);
    canvas.addEventListener('mouseup', () => { game.mouse.down = false; handleInput(); });
    updateBuildMenu(); gameLoop();
}

// --- FIZYKA: CZYTANIE TERENU (Góry istnieją!) ---
function getTerrainCost(x, y) {
    // 1. Jeziora
    if (game.terrain.lakes.some(l => isPointInPolygon(x, y, l.points))) return 60; // Bardzo drogo

    // 2. Góry (Ridges i Szczyty)
    for (let h of game.terrain.hills) {
        if (h.isRidge) {
            // Sprawdź odległość od osi pasma górskiego
            for (let p of h.points) {
                if (Math.hypot(x - p.x, y - p.y) < 40) return 20; // Drogo (Góra)
            }
        } else {
            // Sprawdź odległość od środka góry warstwowej
            if (h.layers[0] && Math.hypot(x - h.x, y - h.y) < h.layers[0].radius) return 20;
        }
    }
    return 1; // Trawa
}

// --- AI: FLOW FIELD (Pathfinding) ---
function generateFlowField() {
    const cols = Math.ceil(CONFIG.WIDTH / CONFIG.PATH_GRID);
    const rows = Math.ceil(CONFIG.HEIGHT / CONFIG.PATH_GRID);
    const core = game.entities.find(e => e.type === 'core') || {x: 600, y: 450};
    const costField = new Array(cols).fill(0).map(() => new Array(rows).fill(9999));
    const targetX = Math.floor(core.x / CONFIG.PATH_GRID);
    const targetY = Math.floor(core.y / CONFIG.PATH_GRID);

    let q = [{x: targetX, y: targetY, c: 0}];
    costField[targetX][targetY] = 0;

    while(q.length > 0) {
        let curr = q.shift();
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
            let nx = curr.x + d[0], ny = curr.y + d[1];
            if(nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                let wx = nx * CONFIG.PATH_GRID + 20, wy = ny * CONFIG.PATH_GRID + 20;
                let tileCost = getTerrainCost(wx, wy); // Używamy tej samej funkcji co fizyka
                
                let total = curr.c + tileCost;
                if (total < costField[nx][ny]) {
                    costField[nx][ny] = total; q.push({x: nx, y: ny, c: total});
                }
            }
        });
    }

    game.flowField = new Array(cols).fill(0).map((_, x) => new Array(rows).fill(0).map((_, y) => {
        let min = costField[x][y], vec = {x: 0, y: 0};
        [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d => {
            let nx = x + d[0], ny = y + d[1];
            if(nx >= 0 && nx < cols && ny >= 0 && ny < rows && costField[nx][ny] < min) {
                min = costField[nx][ny]; vec = {x: d[0], y: d[1]};
            }
        });
        // Normalizacja
        let len = Math.hypot(vec.x, vec.y);
        if(len > 0) { vec.x /= len; vec.y /= len; }
        return vec;
    }));
}

// --- ORYGINALNY GENERATOR (1:1 Z TWOJEGO KODU) ---
function generateStrategicMap() {
    game.spawnDir = ['NORTH', 'SOUTH', 'EAST', 'WEST'][Math.floor(Math.random() * 4)];
    game.terrain = { hills: [], lakes: [], forests: [] };
    const S = CONFIG.SCALE;
    
    // GÓRY (Ridges + Peaks)
    const featureCount = 3 + Math.floor(Math.random() * 3);
    for(let f = 0; f < featureCount; f++) {
        const type = Math.random();
        if(type < 0.5) {
            // RIDGES
            const isHorizontal = Math.random() > 0.5;
            const ridgePoints = [];
            const startPos = (150 + Math.random() * 1200) * S;
            const amplitude = (60 + Math.random() * 100) * S;
            const frequency = 0.4 + Math.random() * 0.4;
            for(let i = 0; i <= 15; i++) {
                const t = i / 15;
                const offset = Math.sin(t * Math.PI * frequency * 2) * amplitude + (Math.random() - 0.5) * 30 * S;
                if(isHorizontal) ridgePoints.push({ x: (100 + t * 2200) * S, y: startPos + offset });
                else ridgePoints.push({ x: startPos + offset, y: (100 + t * 1700) * S });
            }
            const peakPos = 0.3 + Math.random() * 0.4;
            const maxHeight = (150 + Math.random() * 120) * S;
            for(let level = 0; level < 8; level++) {
                const elevation = level / 8;
                const currentHeight = maxHeight * (1 - elevation);
                for(let side of [-1, 1]) {
                    const points = [];
                    for(let i = 0; i <= 15; i++) {
                        const t = i / 15;
                        const peakness = 1 - Math.abs(t - peakPos) / Math.max(peakPos, 1 - peakPos);
                        const heightHere = maxHeight * peakness * (0.6 + Math.random() * 0.4);
                        if(heightHere < currentHeight) continue;
                        const width = (heightHere - currentHeight) * 0.7;
                        const ridge = ridgePoints[i];
                        let perpX, perpY;
                        if(i < 15) {
                            const next = ridgePoints[i + 1]; const dx = next.x - ridge.x; const dy = next.y - ridge.y; const len = Math.sqrt(dx*dx + dy*dy);
                            perpX = -dy / len; perpY = dx / len;
                        } else {
                            const prev = ridgePoints[i - 1]; const dx = ridge.x - prev.x; const dy = ridge.y - prev.y; const len = Math.sqrt(dx*dx + dy*dy);
                            perpX = -dy / len; perpY = dx / len;
                        }
                        points.push({ x: ridge.x + perpX * width * side, y: ridge.y + perpY * width * side });
                    }
                    if(points.length > 3) game.terrain.hills.push({ isRidge: true, points: points, level: level, totalLayers: 8 });
                }
            }
        } else {
            // PEAKS
            const cx = Math.random() * 1200, cy = Math.random() * 900;
            if (type < 0.65) createMountain(cx, cy, 150*S, 10);
            else if (type < 0.8) for(let l=0;l<6;l++) createContourCircle(cx, cy, 180*S*(1-l*0.15), l, 6, 0.2);
            else for(let i=0;i<3;i++) createMountain(cx+(Math.random()-0.5)*200, cy+(Math.random()-0.5)*200, 80*S, 5);
        }
    }
    // JEZIORA
    const lakeCount = 2 + Math.floor(Math.random() * 3);
    for(let l = 0; l < lakeCount; l++) {
        const cx = Math.random()*1200, cy = Math.random()*900, points = [];
        for(let i=0; i<20; i++) {
            const a = (i/20)*Math.PI*2; points.push({x: cx + Math.cos(a)*(60+Math.random()*40), y: cy + Math.sin(a)*(60+Math.random()*40)});
        }
        game.terrain.lakes.push({points});
    }
    // LASY
    const forestCount = 3 + Math.floor(Math.random() * 4);
    for(let f=0; f<forestCount; f++) {
        const cx = Math.random()*1200, cy = Math.random()*900, trees = [];
        for(let t=0; t<15; t++) trees.push({x: cx + (Math.random()-0.5)*200, y: cy + (Math.random()-0.5)*200, size: 8+Math.random()*10});
        game.terrain.forests.push({trees});
    }
}

function createMountain(cx, cy, baseRadius, layers) {
    for(let l = 0; l < layers; l++) {
        const radius = baseRadius * (1 - l / layers); const verts = [];
        for(let i = 0; i < 25; i++) {
            const a = (i / 25) * Math.PI * 2;
            const r = radius * (0.8 + Math.sin(a * 5) * 0.2);
            verts.push({ x: Math.cos(a) * r, y: Math.sin(a) * r });
        }
        game.terrain.hills.push({ x: cx, y: cy, layers: [{ verts, radius, level: l }], totalLayers: layers });
    }
}

function createContourCircle(cx, cy, radius, level, maxLevels, noise) {
    const verts = [];
    for(let i = 0; i < 25; i++) {
        const a = (i / 25) * Math.PI * 2;
        const r = radius * (1 + (Math.random()-0.5)*noise);
        verts.push({ x: Math.cos(a) * r, y: Math.sin(a) * r });
    }
    game.terrain.hills.push({ x: cx, y: cy, layers: [{ verts, radius, level }], totalLayers: maxLevels });
}

// --- LOGIKA GRY ---
function spawnWaveLogic() {
    game.enemies = [];
    let pool = 3000 + (game.wave * 3000);
    while (pool > 0) {
        let r = Math.random(), type = r < 0.4 ? 'LAND' : (r < 0.7 ? 'SWIM' : 'FLY');
        let hp = 100 + Math.random() * 400;
        game.enemies.push(createEnemy(hp, type));
        pool -= hp;
    }
}

function createEnemy(hp, moveType) {
    let x, y;
    if(game.spawnDir === 'NORTH') { x = Math.random()*1200; y = -50; }
    else if(game.spawnDir === 'SOUTH') { x = Math.random()*1200; y = 950; }
    else if(game.spawnDir === 'EAST') { x = 1250; y = Math.random()*900; }
    else { x = -50; y = Math.random()*900; }

    const size = 10 + (hp * 0.03);
    const color = moveType === 'LAND' ? '#ff1111' : (moveType === 'SWIM' ? '#00ffff' : '#cc33ff');
    const verts = []; const pts = 3 + Math.floor(Math.random() * 10);
    for(let i=0; i<pts; i++) verts.push({a: (i/pts)*6.28, d: size * (0.6 + Math.random()*0.8)});
    return { x, y, hp, maxHp: hp, moveType, size, color, verts, speed: moveType==='FLY' ? 1.6 : 1.1 };
}

function updateCombat() {
    // Fizyka Gracza
    let cost = getTerrainCost(game.player.x, game.player.y);
    let mod = cost > 10 ? 0.3 : 1.0; // Jeśli koszt > 10 (Góra/Jezioro) -> Zwolnij
    
    let move = game.player.spd * mod;
    if (game.keys['KeyW']) game.player.y -= move;
    if (game.keys['KeyS']) game.player.y += move;
    if (game.keys['KeyA']) game.player.x -= move;
    if (game.keys['KeyD']) game.player.x += move;
    game.player.x = Math.max(10, Math.min(1190, game.player.x));
    game.player.y = Math.max(10, Math.min(890, game.player.y));

    if (game.mouse.down) playerShoot();

    const core = game.entities.find(e => e.type === 'core');
    if (!core) return;

    game.enemies.forEach((e) => {
        let vx = 0, vy = 0;
        
        // AI Decyzja
        if (e.moveType === 'FLY') {
            let a = Math.atan2(core.y - e.y, core.x - e.x); vx = Math.cos(a); vy = Math.sin(a);
        } else {
            let gx = Math.floor(e.x / CONFIG.PATH_GRID), gy = Math.floor(e.y / CONFIG.PATH_GRID);
            if (game.flowField[gx] && game.flowField[gx][gy] && (game.flowField[gx][gy].x !== 0 || game.flowField[gx][gy].y !== 0)) {
                vx = game.flowField[gx][gy].x; vy = game.flowField[gx][gy].y;
            } else {
                let a = Math.atan2(core.y - e.y, core.x - e.x); vx = Math.cos(a); vy = Math.sin(a);
            }
        }

        // Fizyka Wroga
        let tCost = getTerrainCost(e.x, e.y);
        let speedMod = 1.0;
        
        if (e.moveType === 'LAND') {
            if (tCost === 60) speedMod = 0.2; // Woda = Bardzo wolno
            else if (tCost === 20) speedMod = 0.4; // Góra = Wolno
        } else if (e.moveType === 'SWIM') {
            if (tCost === 60) speedMod = 2.0; // Woda = Bardzo szybko
            else speedMod = 0.8; // Ląd = Wolniej
        }

        e.x += vx * e.speed * speedMod; e.y += vy * e.speed * speedMod;

        // Kolizje (Kamikaze)
        if (Math.hypot(e.x - game.player.x, e.y - game.player.y) < e.size + 10) {
            game.player.hp -= e.hp; e.hp = 0;
            if(game.player.hp <= 0) location.reload();
        }
        game.entities.forEach(ent => {
            if (Math.hypot(e.x - ent.x, e.y - ent.y) < e.size + ent.size) {
                ent.curHP -= e.hp; e.hp = 0;
                if (ent.type === 'core') game.hp = Math.max(0, ent.curHP);
            }
        });
    });

    game.entities.forEach(u => {
        if (u.type === 'tower' && Date.now() - u.lastFire > u.rof) {
            let target = game.enemies.find(e => Math.hypot(e.x - u.x, e.y - u.y) < u.range);
            if (target) {
                target.hp -= u.dmg; u.lastFire = Date.now();
                ctx.strokeStyle = "#ff0"; ctx.beginPath(); ctx.moveTo(u.x, u.y); ctx.lineTo(target.x, target.y); ctx.stroke();
            }
        }
    });

    game.enemies = game.enemies.filter(e => e.hp > 0);
    game.entities = game.entities.filter(e => e.curHP > 0);
    if (game.enemies.length === 0 && game.mode === 'COMBAT') { game.mode = 'BASE'; document.getElementById('actionBtn').innerText = "EXECUTE COMBAT"; document.getElementById('actionBtn').disabled = false; }
    if (game.hp <= 0) location.reload();
}

function drawUnit(x, y, verts, color, hpRatio, size) {
    ctx.save(); ctx.translate(x, y);
    ctx.beginPath();
    verts.forEach((v, i) => (i === 0) ? ctx.moveTo(Math.cos(v.a)*v.d, Math.sin(v.a)*v.d) : ctx.lineTo(Math.cos(v.a)*v.d, Math.sin(v.a)*v.d));
    ctx.closePath(); 
    ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
    ctx.clip(); ctx.fillStyle = color;
    let fillY = size * 2 - (hpRatio * size * 4);
    ctx.fillRect(-size * 2, fillY, size * 4, size * 4);
    ctx.restore();
}

function renderTacticalMap() {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,1200,900);
    
    game.terrain.lakes.forEach(l => {
        ctx.fillStyle = "rgba(150,180,50,0.4)"; ctx.beginPath();
        l.points.forEach((p,i)=>i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y));
        ctx.closePath(); ctx.fill(); ctx.strokeStyle="#9a0"; ctx.stroke();
    });
    
    game.terrain.forests.forEach(f => f.trees.forEach(t => {
        ctx.fillStyle="rgba(150,50,200,0.6)"; ctx.beginPath(); ctx.arc(t.x,t.y,t.size,0,6.28); ctx.fill();
        ctx.strokeStyle="rgba(180,100,255,0.3)"; ctx.stroke();
    }));
    
    game.terrain.hills.forEach(h => {
        if(h.isRidge) {
            let el = h.level/8; ctx.strokeStyle=`rgb(${20+el*180},${30+el*150},${10+el*100})`;
            ctx.beginPath(); h.points.forEach((p,i)=>i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y)); ctx.stroke();
        } else {
            h.layers.forEach(l => {
                let el = l.level/h.totalLayers; ctx.strokeStyle=`rgb(${20+el*180},${30+el*150},${10+el*100})`;
                ctx.beginPath(); l.verts.forEach((v,i)=>i===0?ctx.moveTo(h.x+v.x,h.y+v.y):ctx.lineTo(h.x+v.x,h.y+v.y)); ctx.closePath(); ctx.stroke();
            });
        }
    });
    
    ctx.strokeStyle = "#f44"; ctx.lineWidth = 2; ctx.setLineDash([15, 8]);
    let s = {x:0, y:0, w:0, h:0};
    if(game.spawnDir==='NORTH') s={x:0,y:0,w:1200,h:50}; 
    else if(game.spawnDir==='SOUTH') s={x:0,y:850,w:1200,h:50};
    else if(game.spawnDir==='EAST') s={x:1150,y:0,w:50,h:900};
    else s={x:0,y:0,w:50,h:900};
    ctx.strokeRect(s.x, s.y, s.w, s.h); ctx.setLineDash([]);
}

function gameLoop() {
    ctx.clearRect(0,0,1200,900);
    if(game.mode==='BASE') renderBaseGrid();
    else {
        renderTacticalMap();
        if(game.mode==='COMBAT') updateCombat();
        
        game.entities.forEach(e => {
            let v = []; const s = e.size;
            if(e.type === 'core' || e.type === 'wall') v = [{a:0.78,d:s*1.4},{a:2.35,d:s*1.4},{a:3.92,d:s*1.4},{a:5.49,d:s*1.4}];
            else for(let i=0; i<8; i++) v.push({a: i/8 * Math.PI*2, d: s});
            drawUnit(e.x, e.y, v, e.color, e.curHP/e.hp, s);
        });

        game.enemies.forEach(e => drawUnit(e.x, e.y, e.verts, e.color, e.hp/e.maxHp, e.size));

        if(game.corePlaced) {
            let a = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
            drawUnit(game.player.x, game.player.y, [{a:a,d:15},{a:a+2.5,d:10},{a:a+3.8,d:10}], '#fff', game.player.hp/game.player.maxHp, 10);
        }
        
        renderProjectiles();
        if (game.mode === 'PREP' && game.selected) renderGhost();
    }
    updateStatsUI(); requestAnimationFrame(gameLoop);
}

function playerShoot() {
    if(Date.now()-game.player.lastShot > 150) {
        let a = Math.atan2(game.mouse.y-game.player.y, game.mouse.x-game.player.x);
        game.projectiles.push({x:game.player.x, y:game.player.y, vx:Math.cos(a)*15, vy:Math.sin(a)*15, dmg:50, life:100});
        game.player.lastShot=Date.now();
    }
}

function renderProjectiles() {
    ctx.fillStyle="#fff";
    game.projectiles.forEach((p,i) => {
        p.x+=p.vx; p.y+=p.vy; p.life--; ctx.fillRect(p.x,p.y,4,4);
        let hit = game.enemies.find(e=>Math.hypot(e.x-p.x,e.y-p.y)<e.size);
        if(hit) { hit.hp-=p.dmg; game.projectiles.splice(i,1); }
        if(p.life<=0) game.projectiles.splice(i,1);
    });
}

function handleAction() {
    if(game.mode==='BASE') { game.mode='PREP'; game.wave++; game.entities=[]; game.corePlaced=false; generateStrategicMap(); spawnWaveLogic(); updateBuildMenu(); }
    else if(game.mode==='PREP') { if(!game.corePlaced) return; generateFlowField(); game.mode='COMBAT'; document.getElementById('actionBtn').disabled=true; }
}

function handleInput() {
    if(game.mode==='BASE'&&game.selected) {
        let gx=Math.floor((game.mouse.x-300)/50), gy=Math.floor((game.mouse.y-150)/50);
        if(gx>=0&&gx<12&&gy>=0&&gy<12) { game.buildings.push({gx,gy,cfg:CONFIG.BUILDINGS[game.selected]}); game.money-=CONFIG.BUILDINGS[game.selected].cost; }
    } else if(game.mode==='PREP'&&game.selected) {
        let cfg=CONFIG.DEFENSE[game.selected]; if(cfg.type==='core'&&game.corePlaced) return;
        game.entities.push({...cfg, x:game.mouse.x, y:game.mouse.y, curHP:cfg.hp, lastFire:0});
        if(cfg.type==='core') { game.corePlaced=true; game.player.x=game.mouse.x; game.player.y=game.mouse.y; } else game.money-=cfg.cost;
    }
}

function renderBaseGrid() {
    ctx.strokeStyle="#141";
    for(let i=0;i<=12;i++) { ctx.beginPath(); ctx.moveTo(300+i*50,150); ctx.lineTo(300+i*50,750); ctx.stroke(); ctx.beginPath(); ctx.moveTo(300,150+i*50); ctx.lineTo(900,150+i*50); ctx.stroke(); }
    game.buildings.forEach(b => { ctx.fillStyle=b.cfg.color; ctx.fillRect(305+b.gx*50,155+b.gy*50,40,40); });
}

function renderGhost() {
    const cfg = CONFIG.DEFENSE[game.selected];
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    if (cfg.range) { ctx.beginPath(); ctx.arc(game.mouse.x, game.mouse.y, cfg.range, 0, 6.28); ctx.stroke(); }
    ctx.strokeRect(game.mouse.x-10, game.mouse.y-10, 20, 20);
}

function updateStatsUI() { document.getElementById('ui-money').innerText=`$${game.money}`; document.getElementById('ui-hp').innerText=`${Math.ceil(game.hp/6000*100)}%`; }
function updateBuildMenu() {
    const menu=document.getElementById('buildMenu'); menu.innerHTML="";
    let list=(game.mode==='BASE')?CONFIG.BUILDINGS:CONFIG.DEFENSE;
    for(let k in list) { let btn=document.createElement('button'); btn.className='btn'; btn.innerHTML=`${list[k].name} $${list[k].cost}`; btn.onclick=()=>game.selected=k; menu.appendChild(btn); }
}
function isPointInPolygon(x,y,pts) {
    let inside=false; for(let i=0,j=pts.length-1;i<pts.length;j=i++) {
        if(((pts[i].y>y)!==(pts[j].y>y))&&(x<(pts[j].x-pts[i].x)*(y-pts[i].y)/(pts[j].y-pts[i].y)+pts[i].x)) inside=!inside;
    } return inside;
}
function logTerminal(t) { document.getElementById('terminal').innerHTML += `> ${t}<br>`; }

init();
</script>
</body>
</html>

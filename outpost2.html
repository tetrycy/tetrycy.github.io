<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>OUTPOST '95: COMMANDER EDITION</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root { --f-green: #20ff20; --f-bg: #050a05; --panel: #222; --f-red: #ff2020; --f-blue: #00ffff; }
        body { margin: 0; background: #000; color: var(--f-green); font-family: 'VT323', monospace; display: flex; height: 100vh; overflow: hidden; }
        #viewport { flex-grow: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; }
        canvas { border: 4px solid #333; image-rendering: pixelated; background: #0a110a; cursor: crosshair; }
        #sidebar { width: 320px; background: var(--panel); border-left: 4px solid #444; display: flex; flex-direction: column; padding: 15px; box-shadow: -10px 0 20px #000; }
        .screen { background: #020802; border: 2px solid var(--f-green); padding: 10px; margin-bottom: 10px; }
        .btn { background: #333; color: var(--f-green); border: 3px outset #555; padding: 8px; margin: 3px 0; cursor: pointer; font-family: 'VT323'; font-size: 1.3em; text-transform: uppercase; width: 100%; }
        .btn:hover:not(:disabled) { background: #444; color: #fff; }
        .btn:disabled { opacity: 0.2; cursor: not-allowed; }
        .btn.active { background: #1a4d1a; border-color: var(--f-green); }
        .stat { display: flex; justify-content: space-between; font-size: 1.4em; }
        #terminal { font-size: 0.9em; height: 120px; overflow-y: auto; background: #000; padding: 5px; border: 1px solid #1a331a; color: #8f8; line-height: 1.2; }
    </style>
</head>
<body>

<div id="viewport">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>

<div id="sidebar">
    <h2 style="text-align:center; border-bottom:2px solid var(--f-green); margin:0 0 10px 0;">CMD INTERFACE</h2>
    
    <div class="screen">
        <div class="stat"><span>CREDITS:</span> <span id="ui-money">$800</span></div>
        <div class="stat"><span>POWER:</span> <span id="ui-power">0</span></div>
        <div class="stat"><span>INTEGRITY:</span> <span id="ui-hp">100%</span></div>
    </div>

    <div class="screen" id="terminal">> SELECT SECTOR...<br>> PREPARE DEFENSES.</div>

    <div id="buildMenu" style="flex-grow: 1; overflow-y: auto; margin-bottom: 10px;"></div>

    <button class="btn" id="actionBtn" style="background:#4a1a1a; color:#fff;" onclick="handleAction()">START DEFENSE</button>
</div>

<script>
const CONFIG = {
    GRID: 12, CELL: 50, BASE_OFF: { x: 100, y: 50 },
    BUILDINGS: {
        SOLAR: { name: "SOLAR ARRAY", cost: 150, pwr: 50, color: "#AA0" },
        FARM: { name: "BIO-FARM", cost: 200, pwr: -10, color: "#0A0" },
        MUNITION: { name: "MUNITION FAB", cost: 300, pwr: -30, color: "#A00" }
    },
    DEFENSE: {
        CORE: { name: "OUTPOST CORE", cost: 0, hp: 1000, type: 'core', color: '#0ff' },
        WALL: { name: "METAL WALL", cost: 40, hp: 300, type: 'wall', color: '#555' },
        SENTRY: { name: "SENTRY GUN", cost: 150, range: 200, dmg: 15, rof: 700, hp: 150, type: 'tower', color: '#ff0' },
        ALPHA: { name: "ALPHA MINE", cost: 50, dmg: 100, rad: 70, type: 'mine', color: '#f22' }
    },
    PLAYER_ROF: 110
};

let game = {
    money: 800, hp: 1000, pwr: 0, wave: 0,
    mode: 'BASE', // BASE, PREP, COMBAT
    buildings: [], // Base permanent
    entities: [],  // Combat temporary (Core, Walls, Towers)
    enemies: [], projectiles: [], particles: [],
    hills: [],
    selected: null,
    mouse: { x: 0, y: 0, gx: 0, gy: 0, down: false },
    player: { x: 0, y: 0, active: false, lastShot: 0 },
    corePlaced: false
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function init() {
    canvas.addEventListener('mousemove', e => {
        const r = canvas.getBoundingClientRect();
        game.mouse.x = (e.clientX - r.left) * (800 / r.width);
        game.mouse.y = (e.clientY - r.top) * (600 / r.height);
        game.mouse.gx = Math.floor((game.mouse.x - CONFIG.BASE_OFF.x) / CONFIG.CELL);
        game.mouse.gy = Math.floor((game.mouse.y - CONFIG.BASE_OFF.y) / CONFIG.CELL);
    });
    
    canvas.addEventListener('mousedown', () => { 
        game.mouse.down = true; 
        if (game.mode === 'BASE' || game.mode === 'PREP') handlePlacement();
    });
    canvas.addEventListener('mouseup', () => { game.mouse.down = false; });
    
    window.addEventListener('keydown', e => game.keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => game.keys[e.key.toLowerCase()] = false);
    
    updateBuildMenu();
    gameLoop();
}

function handleAction() {
    if (game.mode === 'BASE') {
        game.mode = 'PREP';
        game.wave++;
        game.corePlaced = false;
        game.entities = [];
        generateTerrain();
        updateBuildMenu();
        document.getElementById('actionBtn').innerText = "LOCK IN & ATTACK";
        logTerminal(`PREP: SECTOR ${game.wave}. PLACE CORE FIRST.`);
    } else if (game.mode === 'PREP') {
        if (!game.corePlaced) {
            logTerminal("ERROR: CORE PLACEMENT REQUIRED.");
            return;
        }
        game.mode = 'COMBAT';
        spawnEnemies();
        document.getElementById('actionBtn').innerText = "COMBAT ACTIVE";
        document.getElementById('actionBtn').disabled = true;
    }
}

function handlePlacement() {
    if (game.mode === 'BASE' && game.selected) {
        const cfg = CONFIG.BUILDINGS[game.selected];
        if (game.money >= cfg.cost && isInsideGrid()) {
            if (!game.buildings.some(b => b.gx === game.mouse.gx && b.gy === game.mouse.gy)) {
                game.buildings.push({ type: game.selected, gx: game.mouse.gx, gy: game.mouse.gy, lv: 1, cfg });
                game.money -= cfg.cost;
                updateStats();
            }
        }
    } else if (game.mode === 'PREP' && game.selected) {
        const cfg = CONFIG.DEFENSE[game.selected];
        
        if (cfg.type === 'core' && game.corePlaced) return;
        
        if (game.money >= cfg.cost) {
            const newEntity = { ...cfg, x: game.mouse.x, y: game.mouse.y, currentHP: cfg.hp, lastFire: 0 };
            game.entities.push(newEntity);
            
            if (cfg.type === 'core') {
                game.corePlaced = true;
                game.player.x = game.mouse.x;
                game.player.y = game.mouse.y;
                game.player.active = true;
            } else {
                game.money -= cfg.cost;
            }
            updateStats();
        }
    }
}

function generateTerrain() {
    game.hills = [];
    const count = 5 + Math.floor(Math.random() * 4);
    for (let i = 0; i < count; i++) {
        game.hills.push({
            x: Math.random() * 800, y: Math.random() * 400 + 50,
            r: 70 + Math.random() * 120,
            layers: 4 + Math.floor(Math.random() * 3),
            seed: Math.random() * 10
        });
    }
}

function spawnEnemies() {
    let pool = 300 + (game.wave * 500);
    while (pool > 0) {
        let hp = Math.min(pool, 40 + Math.random() * (pool * 0.4));
        if (hp < 20) hp = pool;
        game.enemies.push(createEnemy(hp));
        pool -= hp;
    }
}

function createEnemy(hp) {
    const size = 12 + (hp * 0.25);
    const vertices = [];
    const pts = 50 + Math.floor(Math.random() * 30);
    for(let i=0; i<pts; i++) {
        const a = (i/pts) * Math.PI * 2;
        const d = size * (0.6 + Math.random() * 0.8);
        vertices.push({x: Math.cos(a)*d, y: Math.sin(a)*d, baseDist: d});
    }
    // Wrogowie dążą do CORE
    const core = game.entities.find(e => e.type === 'core');
    return { x: Math.random()*800, y: -80, hp, maxHp: hp, size, vertices, speed: 0.5 + (15/size), hitFlash: 0 };
}

function gameLoop() {
    ctx.clearRect(0, 0, 800, 600);
    
    if (game.mode === 'BASE') {
        renderBaseGrid();
    } else {
        renderTopography();
        renderEntities();
        if (game.mode === 'COMBAT') updateCombat();
        if (game.player.active) renderPlayer();
        renderEnemies();
        if (game.mode === 'PREP') renderGhost();
    }

    renderProjectiles();
    renderParticles();
    updateStats();
    requestAnimationFrame(gameLoop);
}

function renderTopography() {
    ctx.strokeStyle = "rgba(0, 255, 0, 0.12)";
    game.hills.forEach(h => {
        for (let l = 1; l <= h.layers; l++) {
            const radius = h.r * (l / h.layers);
            ctx.beginPath();
            for (let a = 0; a < Math.PI * 2; a += 0.25) {
                const px = h.x + Math.cos(a) * (radius + Math.sin(a * 4 + h.seed) * 5);
                const py = h.y + Math.sin(a) * (radius + Math.sin(a * 4 + h.seed) * 5);
                if (a === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath(); ctx.stroke();
        }
    });
}

function updateCombat() {
    if (game.mouse.down) playerShoot();
    
    const core = game.entities.find(e => e.type === 'core');
    const now = Date.now();

    game.enemies.forEach((e, i) => {
        // Ruch w stronę Core
        const ang = Math.atan2(core.y - e.y, core.x - e.x);
        let speedMult = 1;
        game.hills.forEach(h => {
            if (Math.hypot(e.x - h.x, e.y - h.y) < h.r) speedMult = 0.45;
        });

        e.x += Math.cos(ang) * e.speed * speedMult;
        e.y += Math.sin(ang) * e.speed * speedMult;

        // Kolizje z obiektami bazy (Mury, Wieże, Core)
        game.entities.forEach(entity => {
            if (entity.type === 'mine') return;
            const dist = Math.hypot(e.x - entity.x, e.y - entity.y);
            if (dist < e.size + 15) {
                entity.currentHP -= e.hp;
                createParticles(e.x, e.y, "#f00", 20);
                game.enemies.splice(i, 1);
                
                if (entity.type === 'core') game.hp = Math.max(0, entity.currentHP);
            }
        });
    });

    // Wieże strzelają
    game.entities.forEach(u => {
        if (u.type === 'tower' && u.currentHP > 0) {
            const penalty = game.pwr < 0 ? 2 : 1;
            if (now - u.lastFire > u.rof * penalty) {
                const target = game.enemies.find(e => Math.hypot(e.x - u.x, e.y - u.y) < u.range);
                if (target) {
                    target.hp -= u.dmg;
                    u.lastFire = now;
                    renderLaser(u.x, u.y, target.x, target.y);
                }
            }
        }
        // Miny
        if (u.type === 'mine') {
            const trigger = game.enemies.find(e => Math.hypot(e.x - u.x, e.y - u.y) < 30);
            if (trigger) {
                game.enemies.forEach(e => { if(Math.hypot(e.x-u.x, e.y-u.y) < u.rad) e.hp -= u.dmg; });
                createParticles(u.x, u.y, "#f40", 40);
                u.currentHP = 0;
            }
        }
    });

    // Czyszczenie zniszczonych jednostek
    game.entities = game.entities.filter(ent => ent.currentHP > 0 || ent.type === 'mine' && ent.currentHP !== 0);
    game.enemies = game.enemies.filter(e => { if(e.hp <= 0) { game.money += 15; return false; } return true; });

    if (game.enemies.length === 0) {
        game.mode = 'BASE';
        document.getElementById('actionBtn').innerText = "START DEFENSE";
        document.getElementById('actionBtn').disabled = false;
    }
    if (game.hp <= 0) { alert("OUTPOST CORE DESTROYED"); location.reload(); }
}

function playerShoot() {
    const now = Date.now();
    if (now - game.player.lastShot > CONFIG.PLAYER_ROF) {
        const angle = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
        game.projectiles.push({ x: game.player.x, y: game.player.y, vx: Math.cos(angle) * 12, vy: Math.sin(angle) * 12, dmg: 25 });
        game.player.lastShot = now;
    }
}

function renderEntities() {
    game.entities.forEach(ent => {
        ctx.fillStyle = ent.color;
        if (ent.type === 'wall') ctx.fillRect(ent.x - 15, ent.y - 15, 30, 30);
        else if (ent.type === 'core') {
            ctx.beginPath(); ctx.arc(ent.x, ent.y, 25, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#fff"; ctx.stroke();
        } else {
            ctx.fillRect(ent.x - 12, ent.y - 12, 24, 24);
        }
        // Pasek HP nad jednostką
        if (ent.type !== 'mine') {
            ctx.fillStyle = "#300"; ctx.fillRect(ent.x-15, ent.y-25, 30, 4);
            ctx.fillStyle = "#0f0"; ctx.fillRect(ent.x-15, ent.y-25, (ent.currentHP/ent.hp)*30, 4);
        }
    });
}

function renderPlayer() {
    ctx.fillStyle = "#0ff";
    ctx.beginPath(); ctx.arc(game.player.x, game.player.y, 10, 0, Math.PI*2); ctx.fill();
    const angle = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
    ctx.save(); ctx.translate(game.player.x, game.player.y); ctx.rotate(angle);
    ctx.fillStyle = "#fff"; ctx.fillRect(0, -3, 20, 6); ctx.restore();
}

function renderEnemies() {
    game.enemies.forEach(e => {
        ctx.fillStyle = "rgba(255, 30, 30, 0.4)";
        ctx.beginPath(); ctx.moveTo(e.x + e.vertices[0].x, e.y + e.vertices[0].y);
        for(let v=1; v<e.vertices.length; v++) ctx.lineTo(e.x + e.vertices[v].x, e.y + e.vertices[v].y);
        ctx.closePath(); ctx.fill(); ctx.strokeStyle = "#f33"; ctx.stroke();
    });
}

function renderGhost() {
    if (!game.selected) return;
    const cfg = CONFIG.DEFENSE[game.selected];
    ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
    ctx.beginPath(); ctx.arc(game.mouse.x, game.mouse.y, cfg.range || 20, 0, Math.PI*2); ctx.fill();
}

function renderBaseGrid() {
    ctx.strokeStyle = "rgba(0, 255, 0, 0.1)";
    for(let i=0; i<=CONFIG.GRID; i++) {
        ctx.beginPath(); ctx.moveTo(CONFIG.BASE_OFF.x + i*50, CONFIG.BASE_OFF.y); ctx.lineTo(CONFIG.BASE_OFF.x + i*50, CONFIG.BASE_OFF.y + 600); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(CONFIG.BASE_OFF.x, CONFIG.BASE_OFF.y + i*50); ctx.lineTo(CONFIG.BASE_OFF.x + 600, CONFIG.BASE_OFF.y + i*50); ctx.stroke();
    }
    game.buildings.forEach(b => {
        ctx.fillStyle = b.cfg.color;
        ctx.fillRect(CONFIG.BASE_OFF.x + b.gx*50+5, CONFIG.BASE_OFF.y + b.gy*50+5, 40, 40);
    });
}

function renderProjectiles() {
    game.projectiles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy;
        ctx.fillStyle = "#fff"; ctx.fillRect(p.x-2, p.y-2, 4, 4);
        const hit = game.enemies.find(e => Math.hypot(e.x - p.x, e.y - p.y) < e.size);
        if (hit) { hit.hp -= p.dmg; game.projectiles.splice(i, 1); }
        if (p.x < 0 || p.x > 800 || p.y < 0 || p.y > 600) game.projectiles.splice(i, 1);
    });
}

function updateStats() {
    let p = 0; game.buildings.forEach(b => p += b.cfg.pwr * b.lv); game.pwr = p;
    document.getElementById('ui-money').innerText = `$${Math.floor(game.money)}`;
    document.getElementById('ui-power').innerText = `${game.pwr} PWR`;
    document.getElementById('ui-hp').innerText = `${Math.max(0, Math.ceil((game.hp/1000)*100))}%`;
}

function renderLaser(x1, y1, x2, y2) { ctx.strokeStyle = "#ff0"; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); }
function createParticles(x, y, c, count) { for(let i=0; i<count; i++) game.particles.push({x, y, vx:Math.random()*8-4, vy:Math.random()*8-4, life:1, c}); }
function renderParticles() { game.particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.04; ctx.fillStyle = p.c; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 3, 3); if(p.life <= 0) game.particles.splice(i, 1); }); ctx.globalAlpha = 1; }

function updateBuildMenu() {
    const menu = document.getElementById('buildMenu'); menu.innerHTML = "";
    const list = (game.mode === 'BASE') ? CONFIG.BUILDINGS : CONFIG.DEFENSE;
    for(let k in list) {
        const item = list[k];
        const locked = item.req && !game.buildings.some(b => b.cfg.name === item.req);
        const btn = document.createElement('button');
        btn.className = 'btn' + (game.selected === k ? ' active' : '');
        btn.disabled = locked;
        btn.innerHTML = `${item.name} <br> <span style="font-size:0.7em">$${item.cost}</span>`;
        btn.onclick = () => { game.selected = k; updateBuildMenu(); };
        menu.appendChild(btn);
    }
}

function isInsideGrid() { return game.mouse.gx>=0 && game.mouse.gx<CONFIG.GRID && game.mouse.gy>=0 && game.mouse.gy<CONFIG.GRID; }
function logTerminal(t) { document.getElementById('terminal').innerHTML += `> ${t}<br>`; }

init();
</script>
</body>
</html>

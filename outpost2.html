<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>OUTPOST '95: SUPREME COMMANDER</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root { --f-green: #20ff20; --f-bg: #050805; --panel: #1a1c1a; --f-red: #ff3333; --f-blue: #33aaff; --f-purple: #cc33ff; --f-hp: #ffff00; }
        body { margin: 0; background: #000; color: var(--f-green); font-family: VT323, monospace; display: flex; height: 100vh; overflow: hidden; }
        #viewport { flex-grow: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; padding: 10px; }
        canvas { border: 2px solid var(--f-green); background: var(--f-bg); cursor: crosshair; image-rendering: crisp-edges; }
        #sidebar { width: 340px; background: var(--panel); border-left: 4px ridge #444; display: flex; flex-direction: column; padding: 15px; }
        .screen { background: #000; border: 1px solid var(--f-green); padding: 10px; margin-bottom: 8px; box-shadow: inset 0 0 15px rgba(0,255,0,0.2); }
        .btn { background: #222; color: var(--f-green); border: 2px solid var(--f-green); padding: 6px; margin: 3px 0; cursor: pointer; font-family: VT323; font-size: 1.1em; text-transform: uppercase; width: 100%; text-align: left; }
        .btn:hover:not(:disabled) { background: var(--f-green); color: #000; }
        .btn.active { background: #083308; box-shadow: 0 0 10px var(--f-green); }
        .stat { display: flex; justify-content: space-between; font-size: 1.3em; }
        #terminal { font-size: 0.82em; height: 140px; overflow-y: auto; color: #8f8; border: 1px solid #1a331a; padding: 5px; background: #020502; line-height: 1.2; }
        .upgrade-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-top: 5px; }
    </style>
</head>
<body>

<div id="viewport">
    <canvas id="gameCanvas" width="1200" height="900"></canvas>
</div>

<div id="sidebar">
    <h2 style="text-align:center; border-bottom:2px solid var(--f-green); margin:0 0 10px 0;">STRAT-COM INTERFACE</h2>
    
    <div class="screen">
        <div class="stat"><span>CREDITS:</span> <span id="ui-money">$800</span></div>
        <div class="stat"><span>HQ HULL:</span> <span id="ui-hp">100%</span></div>
        <div id="unit-info" style="font-size:0.75em; color:#888; border-top:1px solid #333; margin-top:5px; padding-top:5px;">
            UNIT-01: SPD <span id="p-spd">1.0</span> | ROF <span id="p-rof">1.0</span> | DMG <span id="p-dmg">1.0</span>
        </div>
    </div>

    <div class="screen" id="terminal">> AWAITING MISSION...</div>

    <div id="buildMenu" style="flex-grow: 1; overflow-y: auto;"></div>

    <button class="btn" id="actionBtn" style="background:#400; border-color:#f44; color:#f44; font-weight:bold; text-align:center;" onclick="handleAction()">EXECUTE COMBAT</button>
</div>

<script>
const CONFIG = {
    WIDTH: 1200, HEIGHT: 900,
    BASE_OFF: { x: 150, y: 150 }, CELL: 50, GRID: 12,
    DEFENSE: {
        CORE: { name: "HQ BUNKER", cost: 0, hp: 6000, type: 'core', color: '#0ff' },
        WALL: { name: "HEAVY WALL", cost: 20, hp: 1500, type: 'wall', color: '#666' },
        SENTRY: { name: "AUTO-TURRET", cost: 180, range: 250, dmg: 12, rof: 500, hp: 400, type: 'tower', color: '#ff0' },
        BATTERY: { name: "LR BATTERY", cost: 400, range: 420, dmg: 200, rof: 2800, hp: 600, type: 'tower', color: '#f80' }
    },
    BUILDINGS: {
        SOLAR: { name: "SOLAR ARRAY", cost: 150, pwr: 50, color: "#AA0" },
        FARM: { name: "BIO-FARM", cost: 200, pwr: -10, color: "#0A0" },
        MUNITION: { name: "MUNITION FAB", cost: 450, pwr: -50, color: "#A00" }
    }
};

let game = {
    money: 800, hp: 6000, wave: 0, mode: 'BASE',
    buildings: [], entities: [], enemies: [], projectiles: [],
    hills: [], selected: null, corePlaced: false,
    mouse: { x:0, y:0, down: false },
    keys: {},
    player: { x: 600, y: 450, spd: 3.5, spdLv: 1, rofLv: 1, dmgLv: 1, lastShot: 0 },
    spawnDir: 'NORTH',
    intel: { land: 0, swim: 0, air: 0, totalHP: 0 },
    mapView: 'DETAILED' // 'DETAILED' lub 'SIMPLIFIED'
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function init() {
    window.addEventListener('keydown', e => game.keys[e.code] = true);
    window.addEventListener('keyup', e => game.keys[e.code] = false);
    canvas.addEventListener('mousemove', e => {
        const r = canvas.getBoundingClientRect();
        game.mouse.x = (e.clientX - r.left) * (CONFIG.WIDTH / r.width);
        game.mouse.y = (e.clientY - r.top) * (CONFIG.HEIGHT / r.height);
    });
    canvas.addEventListener('mousedown', () => { game.mouse.down = true; handleInput(); });
    canvas.addEventListener('mouseup', () => game.mouse.down = false);
    updateBuildMenu();
    gameLoop();
}

function handleAction() {
    if (game.mode === 'BASE') {
        game.mode = 'PREP'; game.wave++; game.entities = []; game.corePlaced = false;
        generateStrategicMap(); 
        spawnWaveLogic();
        updateBuildMenu();
        document.getElementById('actionBtn').innerText = "LOCK ALL UNITS";
        showIntelReport();
    } else if (game.mode === 'PREP') {
        if (!game.corePlaced) { logTerminal("CRITICAL: HQ MUST BE DEPLOYED."); return; }
        game.mode = 'COMBAT';
        document.getElementById('actionBtn').innerText = "IN COMBAT";
        document.getElementById('actionBtn').disabled = true;
    }
}

function showIntelReport() {
    logTerminal(`--- INTEL REPORT WAVE ${game.wave} ---`);
    logTerminal(`FRONT: ${game.spawnDir} BORDER`);
    logTerminal(`HOSTILES: ${game.enemies.length} SIGNATURES`);
    logTerminal(`L:${game.intel.land} S:${game.intel.swim} A:${game.intel.air}`);
    logTerminal(`TOTAL MASS: ${Math.floor(game.intel.totalHP)} HP`);
}

function generateStrategicMap() {
    game.spawnDir = ['NORTH', 'SOUTH', 'EAST', 'WEST'][Math.floor(Math.random() * 4)];
    
    // GENERATOR PASM GÓRSKICH
    game.hills = [];
    
    const rangeCount = 2 + Math.floor(Math.random() * 2); // 2-3 pasma
    
    for(let r = 0; r < rangeCount; r++) {
        // RIDGE LINE - linia grzbietu
        const ridgePoints = [];
        const segments = 12;
        
        // Losowa orientacja pasma
        const isHorizontal = Math.random() > 0.5;
        
        // Punkt startowy z marginesem
        const startPos = 150 + Math.random() * (isHorizontal ? CONFIG.HEIGHT - 300 : CONFIG.WIDTH - 300);
        
        // Parametry zakrzywienia
        const amplitude = 80 + Math.random() * 120; // Jak mocno się wije
        const frequency = 0.3 + Math.random() * 0.5;
        const noise = [];
        for(let i = 0; i <= segments; i++) {
            noise.push((Math.random() - 0.5) * 40); // Lokalny szum
        }
        
        // Generuj punkty ridge line
        for(let i = 0; i <= segments; i++) {
            const t = i / segments;
            const baseOffset = Math.sin(t * Math.PI * frequency) * amplitude;
            const localNoise = noise[i];
            
            if(isHorizontal) {
                const x = 100 + t * (CONFIG.WIDTH - 200);
                const y = startPos + baseOffset + localNoise;
                ridgePoints.push({x, y});
            } else {
                const x = startPos + baseOffset + localNoise;
                const y = 100 + t * (CONFIG.HEIGHT - 200);
                ridgePoints.push({x, y});
            }
        }
        
        // WYSOKOŚĆ WZDŁUŻ PASMA (szczyt w środku, opada na końcach)
        const peakPosition = 0.3 + Math.random() * 0.4; // Gdzieś w środku
        const maxHeight = 180 + Math.random() * 140; // Jak wysokie pasmo
        const contourLevels = 8 + Math.floor(Math.random() * 8); // Ile poziomów
        
        // GENERUJ CONTOUR LINES
        for(let level = contourLevels; level > 0; level--) {
            const heightRatio = level / contourLevels;
            const currentHeight = maxHeight * heightRatio;
            
            // Dwie strony pasma (lewa i prawa od ridge)
            for(let side = -1; side <= 1; side += 2) {
                const contourPoints = [];
                
                for(let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    
                    // Wysokość w tym miejscu ridge
                    const peakness = 1 - Math.abs(t - peakPosition) / Math.max(peakPosition, 1 - peakPosition);
                    const heightHere = maxHeight * peakness * (0.5 + Math.random() * 0.5);
                    
                    if(heightHere < currentHeight) continue; // Za nisko, nie rysuj contour
                    
                    // Odległość od ridge dla tego poziomu
                    const falloff = (heightHere - currentHeight) / heightHere;
                    const distance = (1 - falloff) * currentHeight * 0.6;
                    
                    const ridge = ridgePoints[i];
                    
                    // Perpendicular offset
                    let perpX, perpY;
                    if(i < segments) {
                        const next = ridgePoints[i + 1];
                        const dx = next.x - ridge.x;
                        const dy = next.y - ridge.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        perpX = -dy / len;
                        perpY = dx / len;
                    } else {
                        const prev = ridgePoints[i - 1];
                        const dx = ridge.x - prev.x;
                        const dy = ridge.y - prev.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        perpX = -dy / len;
                        perpY = dx / len;
                    }
                    
                    contourPoints.push({
                        x: ridge.x + perpX * distance * side,
                        y: ridge.y + perpY * distance * side
                    });
                }
                
                if(contourPoints.length > 2) {
                    game.hills.push({
                        points: contourPoints,
                        level: level,
                        maxLevels: contourLevels,
                        isContour: true
                    });
                }
            }
        }
    }
}

function spawnWaveLogic() {
    game.enemies = [];
    game.intel = { land: 0, swim: 0, air: 0, totalHP: 0 };
    let pool = 3000 + (game.wave * 4000);
    const r1 = Math.random(), r2 = Math.random(), r3 = Math.random();
    const total = r1+r2+r3;

    while (pool > 0) {
        const r = Math.random();
        let moveType = 'FLY';
        if (r < r1/total) { moveType = 'LAND'; game.intel.land++; }
        else if (r < (r1+r2)/total) { moveType = 'SWIM'; game.intel.swim++; }
        else { game.intel.air++; }

        let hp = 50 + Math.random() * 300;
        if (Math.random() > 0.9) hp = 800 + Math.random() * 800;
        
        game.enemies.push(createEnemy(hp, moveType));
        game.intel.totalHP += hp;
        pool -= hp;
    }
}

function createEnemy(hp, moveType) {
    let x, y, off = 200;
    if(game.spawnDir === 'NORTH') { x = Math.random()*CONFIG.WIDTH; y = -off - Math.random()*1200; }
    else if(game.spawnDir === 'SOUTH') { x = Math.random()*CONFIG.WIDTH; y = CONFIG.HEIGHT + off + Math.random()*1200; }
    else if(game.spawnDir === 'EAST') { x = CONFIG.WIDTH + off + Math.random()*1200; y = Math.random()*CONFIG.HEIGHT; }
    else { x = -off - Math.random()*1200; y = Math.random()*CONFIG.HEIGHT; }

    const size = 5 + (hp * 0.05);
    const vertices = [];
    const pts = 60;
    for(let i=0; i<pts; i++) {
        const a = (i/pts)*Math.PI*2;
        const d = size*(0.6 + Math.random()*0.8);
        vertices.push({x: Math.cos(a)*d, y: Math.sin(a)*d, bD: d});
    }
    let color = moveType==='LAND' ? 'var(--f-red)' : (moveType==='SWIM' ? 'var(--f-blue)' : 'var(--f-purple)');
    return { x, y, hp, maxHp: hp, moveType, size, vertices, color, speed: moveType==='FLY'?(1.5+Math.random()):(0.6 + (5/size)), hitF: 0 };
}

function gameLoop() {
    ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
    if (game.mode === 'BASE') renderBaseGrid();
    else {
        renderTacticalMap();
        if (game.mode === 'COMBAT') updateCombat();
        renderEntities();
        renderAnomalies();
        if (game.corePlaced) renderPlayerUnit();
        if (game.mode === 'PREP' && game.selected) renderGhost();
    }
    renderProjectiles();
    updateStatsUI();
    requestAnimationFrame(gameLoop);
}

function updateCombat() {
    let pSpd = game.player.spd * (1 + (game.player.spdLv-1)*0.2);
    if (game.keys['KeyW']) game.player.y -= pSpd;
    if (game.keys['KeyS']) game.player.y += pSpd;
    if (game.keys['KeyA']) game.player.x -= pSpd;
    if (game.keys['KeyD']) game.player.x += pSpd;
    game.player.x = Math.max(5, Math.min(CONFIG.WIDTH-5, game.player.x));
    game.player.y = Math.max(5, Math.min(CONFIG.HEIGHT-5, game.player.y));

    if (game.mouse.down) playerShoot();

    const core = game.entities.find(e => e.type === 'core');
    if (!core) return;
    
    const now = Date.now();

    game.enemies.forEach((e, i) => {
        const ang = Math.atan2(core.y - e.y, core.x - e.x);
        let mX = Math.cos(ang) * e.speed, mY = Math.sin(ang) * e.speed;

        // TERRAIN MODIFIER - tylko wzgórza
        let terrainMult = 1.0;
        if(e.moveType !== 'FLY') {
            // Sprawdź czy jest w górach (blisko wysokich contour lines)
            let maxElevation = 0;
            game.hills.forEach(h => {
                if(!h.isContour) return;
                
                // Sprawdź odległość do tej contour line
                let minDist = Infinity;
                h.points.forEach(p => {
                    const dist = Math.hypot(e.x - p.x, e.y - p.y);
                    minDist = Math.min(minDist, dist);
                });
                
                // Jeśli blisko (w obrębie 80px) i wysoka contour
                if(minDist < 80) {
                    const elevation = h.level / h.maxLevels;
                    maxElevation = Math.max(maxElevation, elevation);
                }
            });
            
            // Im wyższa wysokość, tym wolniej
            if(maxElevation > 0.3) {
                terrainMult *= 1 - (maxElevation * 0.5); // Max 50% slowdown
            }
        }
        e.x += mX * terrainMult; e.y += mY * terrainMult;

        e.vertices.forEach(v => {
            const jitter = (Math.random()-0.5)*2.5;
            const a = Math.atan2(v.y, v.x);
            v.x = Math.cos(a) * (v.bD + jitter); v.y = Math.sin(a) * (v.bD + jitter);
        });

        game.entities.forEach(ent => {
            if (ent.type === 'mine') return;
            if (Math.hypot(e.x - ent.x, e.y - ent.y) < e.size + 15) {
                ent.curHP -= e.hp; game.enemies.splice(i, 1);
                if (ent.type === 'core') game.hp = Math.max(0, ent.curHP);
            }
        });
    });

    game.entities.forEach(u => {
        if (u.type === 'tower' && now - u.lastFire > u.rof) {
            const target = game.enemies.find(e => Math.hypot(e.x - u.x, e.y - u.y) < u.range);
            if (target) {
                target.hp -= u.dmg; target.hitF = 3; u.lastFire = now;
                ctx.strokeStyle = "rgba(255,255,0,0.5)"; ctx.beginPath(); ctx.moveTo(u.x, u.y); ctx.lineTo(target.x, target.y); ctx.stroke();
            }
        }
    });

    game.enemies = game.enemies.filter(e => { if (e.hp <= 0) { game.money += 15; return false; } return true; });
    if (game.enemies.length === 0) { game.mode = 'BASE'; document.getElementById('actionBtn').innerText = "EXECUTE COMBAT"; document.getElementById('actionBtn').disabled = false; logTerminal("THREATS NEUTRALIZED."); }
    if (game.hp <= 0) { alert("HQ OVERRUN"); location.reload(); }
}

function renderAnomalies() {
    game.enemies.forEach(e => {
        ctx.fillStyle = e.hitF > 0 ? "#fff" : e.color;
        ctx.beginPath(); ctx.moveTo(e.x + e.vertices[0].x, e.y + e.vertices[0].y);
        for(let v=1; v<e.vertices.length; v++) ctx.lineTo(e.x + e.vertices[v].x, e.y + e.vertices[v].y);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.stroke();

        const barW = Math.max(25, e.size * 2);
        ctx.fillStyle = "#400"; ctx.fillRect(e.x - barW/2, e.y - e.size - 15, barW, 6);
        ctx.fillStyle = "var(--f-hp)"; ctx.fillRect(e.x - barW/2, e.y - e.size - 15, barW * (e.hp/e.maxHp), 6);
        if(e.hitF > 0) e.hitF--;
    });
}

function renderTacticalMap() {
    // CZARNE TŁO
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);
    
    // Subtelny grid pomocniczy (tylko w DETAILED)
    if(game.mapView === 'DETAILED') {
        ctx.strokeStyle = "rgba(0, 100, 0, 0.06)";
        ctx.lineWidth = 1;
        for(let i=0; i<=CONFIG.WIDTH; i+=150) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, CONFIG.HEIGHT);
            ctx.stroke();
        }
        for(let i=0; i<=CONFIG.HEIGHT; i+=150) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(CONFIG.WIDTH, i);
            ctx.stroke();
        }
    }
    
    // LINIE KONTUROWE - pasma górskie
    game.hills.forEach(h => {
        if(!h.isContour) return;
        
        // SIMPLIFIED VIEW - tylko co 3. linia
        if(game.mapView === 'SIMPLIFIED' && h.level % 3 !== 0) return;
        
        // Procent wysokości (0 = dół, 1 = szczyt)
        const elevation = h.level / h.maxLevels;
        
        // Gradient: ciemny brąz → brąz → beż → jasny
        let r, g, b;
        if(elevation < 0.3) {
            r = 20 + elevation * 100;
            g = 30 + elevation * 120;
            b = 10 + elevation * 80;
        } else if(elevation < 0.6) {
            const t = (elevation - 0.3) / 0.3;
            r = 50 + t * 80;
            g = 60 + t * 80;
            b = 30 + t * 60;
        } else {
            const t = (elevation - 0.6) / 0.4;
            r = 130 + t * 90;
            g = 140 + t * 90;
            b = 90 + t * 120;
        }
        
        // Co 5. linia grubsza
        const isEveryFifth = h.level % 5 === 0;
        const lineWidth = game.mapView === 'SIMPLIFIED' ? 2 : (isEveryFifth ? 2.5 : 1.2);
        
        ctx.strokeStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        ctx.lineWidth = lineWidth;
        
        // Rysuj contour line
        ctx.beginPath();
        h.points.forEach((p, i) => {
            if(i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();
    });
    
    // SPAWN ZONE - minimalistyczny
    ctx.strokeStyle = "#f44";
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 8]);
    
    let spawnZone = {x: 0, y: 0, w: 0, h: 0};
    if(game.spawnDir === 'NORTH') {
        spawnZone = {x: 0, y: 0, w: CONFIG.WIDTH, h: 120};
    } else if(game.spawnDir === 'SOUTH') {
        spawnZone = {x: 0, y: CONFIG.HEIGHT - 120, w: CONFIG.WIDTH, h: 120};
    } else if(game.spawnDir === 'EAST') {
        spawnZone = {x: CONFIG.WIDTH - 120, y: 0, w: 120, h: CONFIG.HEIGHT};
    } else {
        spawnZone = {x: 0, y: 0, w: 120, h: CONFIG.HEIGHT};
    }
    
    ctx.strokeRect(spawnZone.x, spawnZone.y, spawnZone.w, spawnZone.h);
    ctx.setLineDash([]);
    
    // Strzałki kierunku
    ctx.fillStyle = "#f44";
    ctx.strokeStyle = "#f44";
    ctx.lineWidth = 1.5;
    
    const arrowCount = game.spawnDir === 'NORTH' || game.spawnDir === 'SOUTH' ? 9 : 6;
    for(let i = 0; i < arrowCount; i++) {
        let ax, ay;
        if(game.spawnDir === 'NORTH') {
            ax = (i + 1) * (CONFIG.WIDTH / (arrowCount + 1));
            ay = 60;
            drawArrow(ax, ay, Math.PI/2, 15);
        } else if(game.spawnDir === 'SOUTH') {
            ax = (i + 1) * (CONFIG.WIDTH / (arrowCount + 1));
            ay = CONFIG.HEIGHT - 60;
            drawArrow(ax, ay, -Math.PI/2, 15);
        } else if(game.spawnDir === 'EAST') {
            ax = CONFIG.WIDTH - 60;
            ay = (i + 1) * (CONFIG.HEIGHT / (arrowCount + 1));
            drawArrow(ax, ay, Math.PI, 15);
        } else {
            ax = 60;
            ay = (i + 1) * (CONFIG.HEIGHT / (arrowCount + 1));
            drawArrow(ax, ay, 0, 15);
        }
    }
    
    // Label spawnu - minimalistyczny
    ctx.fillStyle = "#f44";
    ctx.font = "18px VT323";
    ctx.textAlign = "center";
    const labelText = `${game.spawnDir} FRONT`;
    if(game.spawnDir === 'NORTH') ctx.fillText(labelText, CONFIG.WIDTH/2, 30);
    else if(game.spawnDir === 'SOUTH') ctx.fillText(labelText, CONFIG.WIDTH/2, CONFIG.HEIGHT - 15);
    else if(game.spawnDir === 'EAST') {
        ctx.save();
        ctx.translate(CONFIG.WIDTH - 25, CONFIG.HEIGHT/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(labelText, 0, 0);
        ctx.restore();
    } else {
        ctx.save();
        ctx.translate(25, CONFIG.HEIGHT/2);
        ctx.rotate(Math.PI/2);
        ctx.fillText(labelText, 0, 0);
        ctx.restore();
    }
}

function drawArrow(x, y, angle, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.lineTo(-size/2, size/2);
    ctx.lineTo(0, 0);
    ctx.lineTo(size/2, size/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
}

function renderPlayerUnit() {
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(game.player.x, game.player.y-12); ctx.lineTo(game.player.x+12, game.player.y); ctx.lineTo(game.player.x, game.player.y+12); ctx.lineTo(game.player.x-12, game.player.y); ctx.closePath(); ctx.stroke();
    ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(game.player.x, game.player.y, 2, 0, Math.PI*2); ctx.fill();
    const a = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
    ctx.setLineDash([2, 4]); ctx.beginPath(); ctx.moveTo(game.player.x, game.player.y); ctx.lineTo(game.player.x+Math.cos(a)*40, game.player.y+Math.sin(a)*40); ctx.stroke(); ctx.setLineDash([]);
}

function playerShoot() {
    const now = Date.now();
    const rof = 140 / (1 + (game.player.rofLv-1)*0.3);
    const dmg = 35 * (1 + (game.player.dmgLv-1)*0.5);
    if (now - game.player.lastShot > rof) {
        const a = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
        game.projectiles.push({ x: game.player.x, y: game.player.y, vx: Math.cos(a)*22, vy: Math.sin(a)*22, dmg });
        game.player.lastShot = now;
    }
}

function renderEntities() {
    game.entities.forEach(ent => {
        ctx.strokeStyle = ent.color; ctx.lineWidth = 2;
        if (ent.type === 'core') ctx.strokeRect(ent.x-15, ent.y-15, 30, 30);
        else if (ent.type === 'wall') ctx.strokeRect(ent.x-10, ent.y-10, 20, 20);
        else { ctx.beginPath(); ctx.arc(ent.x, ent.y, 10, 0, Math.PI*2); ctx.stroke(); }
        ctx.fillStyle = "var(--f-green)"; ctx.fillRect(ent.x-12, ent.y+18, (ent.curHP/ent.hp)*24, 3);
    });
}

function handleInput() {
    if (game.mode === 'BASE' && game.selected) {
        const gx = Math.floor((game.mouse.x - 150) / 50), gy = Math.floor((game.mouse.y - 150) / 50);
        if(gx>=0 && gx<12 && gy>=0 && gy<12) {
            game.buildings.push({ gx, gy, cfg: CONFIG.BUILDINGS[game.selected] });
            game.money -= CONFIG.BUILDINGS[game.selected].cost; updateStatsUI();
        }
    } else if (game.mode === 'PREP' && game.selected) {
        const cfg = CONFIG.DEFENSE[game.selected];
        if (cfg.type === 'core' && game.corePlaced) return;
        if (game.money >= cfg.cost) {
            game.entities.push({ ...cfg, x: game.mouse.x, y: game.mouse.y, curHP: cfg.hp, lastFire: 0 });
            if (cfg.type === 'core') { game.corePlaced = true; game.player.x = game.mouse.x; game.player.y = game.mouse.y; }
            else game.money -= cfg.cost;
            updateStatsUI();
        }
    }
}

function renderProjectiles() {
    ctx.fillStyle = "#fff";
    game.projectiles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; ctx.fillRect(p.x, p.y, 3, 3);
        const hit = game.enemies.find(e => Math.hypot(e.x - p.x, e.y - p.y) < e.size);
        if (hit) { hit.hp -= p.dmg; hit.hitF = 3; game.projectiles.splice(i, 1); }
        if (p.x < 0 || p.x > CONFIG.WIDTH || p.y < 0 || p.y > CONFIG.HEIGHT) game.projectiles.splice(i, 1);
    });
}

function renderBaseGrid() {
    ctx.strokeStyle = "rgba(32, 255, 32, 0.1)";
    for(let i=0; i<=12; i++) {
        ctx.beginPath(); ctx.moveTo(150+i*50, 150); ctx.lineTo(150+i*50, 750); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(150, 150+i*50); ctx.lineTo(750, 150+i*50); ctx.stroke();
    }
    game.buildings.forEach(b => { ctx.fillStyle = b.cfg.color; ctx.fillRect(150+b.gx*50+5, 150+b.gy*50+5, 40, 40); });
}

function renderGhost() {
    const cfg = CONFIG.DEFENSE[game.selected];
    ctx.strokeStyle = "rgba(255,255,255,0.3)";
    if (cfg.range) { ctx.beginPath(); ctx.arc(game.mouse.x, game.mouse.y, cfg.range, 0, Math.PI*2); ctx.stroke(); }
    ctx.strokeRect(game.mouse.x-10, game.mouse.y-10, 20, 20);
}

function updateStatsUI() {
    document.getElementById('ui-money').innerText = `$${Math.floor(game.money)}`;
    document.getElementById('ui-hp').innerText = `${Math.max(0, Math.ceil((game.hp/6000)*100))}%`;
    document.getElementById('p-spd').innerText = (1 + (game.player.spdLv-1)*0.2).toFixed(1);
    document.getElementById('p-rof').innerText = (1 + (game.player.rofLv-1)*0.3).toFixed(1);
    document.getElementById('p-dmg').innerText = (1 + (game.player.dmgLv-1)*0.5).toFixed(1);
}

function updateBuildMenu() {
    const menu = document.getElementById('buildMenu'); menu.innerHTML = "";
    const list = (game.mode === 'BASE') ? CONFIG.BUILDINGS : CONFIG.DEFENSE;
    for(let k in list) {
        const item = list[k];
        const btn = document.createElement('button');
        btn.className = 'btn' + (game.selected === k ? ' active' : '');
        btn.innerHTML = `${item.name} <span style="float:right">$${item.cost}</span>`;
        btn.onclick = () => { game.selected = k; updateBuildMenu(); };
        menu.appendChild(btn);
    }
    
    // VIEW TOGGLE w trybie PREP
    if(game.mode === 'PREP') {
        const viewBtn = document.createElement('button');
        viewBtn.className = 'btn';
        viewBtn.style.marginTop = '15px';
        viewBtn.style.background = '#333';
        viewBtn.style.borderColor = '#888';
        viewBtn.innerHTML = `MAP VIEW: ${game.mapView}`;
        viewBtn.onclick = () => {
            game.mapView = game.mapView === 'DETAILED' ? 'SIMPLIFIED' : 'DETAILED';
            updateBuildMenu();
        };
        menu.appendChild(viewBtn);
    }
    
    if(game.mode === 'BASE') {
        const row = document.createElement('div'); row.className = 'upgrade-row';
        ['SPD', 'ROF', 'DMG'].forEach(s => {
            const b = document.createElement('button'); b.className = 'btn'; b.style.fontSize = '0.7em';
            b.innerText = `UP ${s}`;
            b.onclick = () => { 
                let cost = game.player[s.toLowerCase()+'Lv']*300;
                if(game.money >= cost) { game.money -= cost; game.player[s.toLowerCase()+'Lv']++; updateStatsUI(); updateBuildMenu(); }
            };
            row.appendChild(b);
        });
        menu.appendChild(row);
    }
}

function logTerminal(t) { 
    const term = document.getElementById('terminal');
    term.innerHTML += `> ${t}<br>`; term.scrollTop = term.scrollHeight;
}

window.handleAction = handleAction;

init();
</script>
</body>
</html>

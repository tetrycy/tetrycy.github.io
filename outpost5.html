<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Generator Map Topograficznych</title>
    <style>
        body { margin: 0; background: #222; color: #fff; font-family: monospace; overflow: hidden; display: flex; height: 100vh; }
        #sidebar { 
            width: 300px; background: #333; padding: 20px; display: flex; flex-direction: column; gap: 15px; 
            box-shadow: 2px 0 10px rgba(0,0,0,0.5); z-index: 10;
        }
        #viewport { flex-grow: 1; display: flex; justify-content: center; align-items: center; background: #111; position: relative; }
        canvas { 
            background: #fff; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5); 
            max-width: 95%; max-height: 95%;
            image-rendering: pixelated; /* Dla ostrości */
        }
        .control { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 0.8em; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        input[type="range"] { width: 100%; cursor: pointer; }
        button { 
            background: #4a90e2; color: white; border: none; padding: 15px; 
            font-family: monospace; font-size: 1.2em; cursor: pointer; margin-top: 10px; 
            transition: 0.2s;
        }
        button:hover { background: #357abd; }
        .val-disp { float: right; color: #4a90e2; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2 style="margin: 0 0 10px 0; border-bottom: 2px solid #555; padding-bottom: 10px;">TOPO-GEN v1.0</h2>
    
    <div class="control">
        <label>Skala (Zoom) <span id="val-scale" class="val-disp">50</span></label>
        <input type="range" id="scale" min="20" max="150" value="60">
    </div>

    <div class="control">
        <label>Szczegółowość (Octaves) <span id="val-oct" class="val-disp">4</span></label>
        <input type="range" id="octaves" min="1" max="8" value="5">
    </div>

    <div class="control">
        <label>Gęstość Linii (Izolinie) <span id="val-lines" class="val-disp">15</span></label>
        <input type="range" id="lines" min="5" max="50" value="20">
    </div>

    <div class="control">
        <label>Poziom Wody <span id="val-water" class="val-disp">0.3</span></label>
        <input type="range" id="water" min="0" max="80" value="25">
    </div>

    <div class="control">
        <label>Styl Mapy</label>
        <select id="style" style="padding: 10px; background: #222; color: #fff; border: 1px solid #555;">
            <option value="topo">Topograficzna (Kolor)</option>
            <option value="print">Druk (Czarno-Biała)</option>
            <option value="heat">Mapa Ciepła (Heatmap)</option>
        </select>
    </div>

    <button onclick="generate()">GENERUJ NOWĄ</button>
    <div style="margin-top:auto; font-size: 0.7em; color: #666;">
        Generator oparty na szumie fraktalnym (FBM).<br>
        Generuje wysokość dla każdego piksela.
    </div>
</div>

<div id="viewport">
    <canvas id="mapCanvas" width="800" height="600"></canvas>
</div>

<script>
// --- KONFIGURACJA I ZMIENNE ---
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
let seed = Math.random() * 10000;

// --- PROSTA IMPLEMENTACJA SZUMU (Pseudo-Perlin) ---
// Tworzymy tablicę permutacji dla losowości
const perm = new Uint8Array(512);
const p = new Uint8Array(256);
function initSeed() {
    for(let i=0; i<256; i++) p[i] = i;
    for(let i=0; i<256; i++) { // Tasowanie (Fisher-Yates)
        let r = Math.floor(Math.random() * 256);
        let temp = p[i]; p[i] = p[r]; p[r] = temp;
    }
    for(let i=0; i<512; i++) perm[i] = p[i & 255];
}

function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(t, a, b) { return a + t * (b - a); }
function grad(hash, x, y) {
    const h = hash & 15;
    const u = h < 8 ? x : y, v = h < 4 ? y : (h === 12 || h === 14 ? x : 0);
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}

function noise2D(x, y) {
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
    x -= Math.floor(x); y -= Math.floor(y);
    const u = fade(x), v = fade(y);
    const A = perm[X] + Y, B = perm[X + 1] + Y;
    return lerp(v, lerp(u, grad(perm[A], x, y), grad(perm[B], x - 1, y)),
                   lerp(u, grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1)));
}

// --- FRACTAL BROWNIAN MOTION (FBM) ---
// To tworzy "naturalność" terenu przez nakładanie warstw szumu
function fbm(x, y, octaves) {
    let total = 0;
    let amplitude = 1;
    let frequency = 1;
    let maxValue = 0;  // Używane do normalizacji

    for(let i=0; i<octaves; i++) {
        total += noise2D(x * frequency, y * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2;
    }
    
    // Normalizacja do zakresu 0 - 1
    return (total / maxValue) + 0.5; 
}

// --- GENERATOR MAPY ---
function generate() {
    // Pobranie wartości z UI
    const scale = parseInt(document.getElementById('scale').value);
    const octaves = parseInt(document.getElementById('octaves').value);
    const lineDensity = parseInt(document.getElementById('lines').value);
    const waterLevel = parseInt(document.getElementById('water').value) / 100;
    const style = document.getElementById('style').value;

    // Aktualizacja wyświetlanych wartości
    document.getElementById('val-scale').innerText = scale;
    document.getElementById('val-oct').innerText = octaves;
    document.getElementById('val-lines').innerText = lineDensity;
    document.getElementById('val-water').innerText = waterLevel;

    // Nowe ziarno losowości przy generowaniu (tylko jeśli kliknięto przycisk)
    // Jeśli tylko przesuwamy suwaki, chcemy widzieć zmiany na TYM SAMYM terenie
    // W tej wersji uprościmy: przycisk losuje seed, suwaki zmieniają parametry
}

// Funkcja rysująca piksel po pikselu
function draw() {
    const width = canvas.width;
    const height = canvas.height;
    
    // Tworzymy bufor obrazu (szybkie rysowanie)
    const imgData = ctx.createImageData(width, height);
    const data = imgData.data;

    // Parametry z UI
    const zoom = parseInt(document.getElementById('scale').value) / 1000;
    const octaves = parseInt(document.getElementById('octaves').value);
    const steps = parseInt(document.getElementById('lines').value);
    const waterLvl = parseInt(document.getElementById('water').value) / 100;
    const mapStyle = document.getElementById('style').value;

    // Pętla po wszystkich pikselach
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            
            // 1. Obliczamy wysokość w tym punkcie (0.0 do 1.0)
            let h = fbm(x * zoom + seed, y * zoom + seed, octaves);
            
            // 2. Koloryzacja
            let r, g, b;

            // Logika Izolinii (Czy ten piksel jest na granicy wysokości?)
            // Mnożymy wysokość przez liczbę kroków i sprawdzamy część ułamkową
            let contour = (h * steps) % 1; 
            let isLine = contour < 0.1 && h > waterLvl; // 0.1 to grubość linii

            if (mapStyle === 'print') {
                // STYL CZARNO-BIAŁY (Klasyczny techniczny)
                if (h < waterLvl) { // Woda
                    r = g = b = 240; // Jasnoszary
                } else if (isLine) { // Linia
                    r = g = b = 0; // Czarny
                } else { // Ląd
                    r = g = b = 255; // Biały
                }
            } 
            else if (mapStyle === 'heat') {
                // STYL HEATMAP (Dobra do debugowania wysokości)
                if (h < waterLvl) { r=0; g=0; b=150; }
                else if (isLine) { r=0; g=0; b=0; }
                else {
                    r = h * 255;
                    g = (1-h) * 50;
                    b = 0;
                }
            }
            else {
                // STYL TOPOGRAFICZNY (Kolorowy)
                if (h < waterLvl) {
                    // Woda (Głębia)
                    let wDepth = h / waterLvl; 
                    r = 50 * wDepth; g = 100 * wDepth; b = 200 + 55 * wDepth;
                } else if (isLine) {
                    // Kontur (Brązowy ciemny)
                    r = 60; g = 40; b = 20;
                } else {
                    // Ląd (Hipsometria)
                    if (h < 0.4) { // Niziny (Zielony)
                        r = 100; g = 180; b = 100;
                    } else if (h < 0.6) { // Wyżyny (Żółty/Beż)
                        r = 210; g = 200; b = 130;
                    } else if (h < 0.8) { // Góry (Brąz)
                        r = 160; g = 100; b = 60;
                    } else { // Szczyty (Biały/Szary)
                        r = 220; g = 220; b = 220;
                    }
                    
                    // Cieniowanie (lekki gradient w ramach strefy)
                    r *= (0.9 + contour*0.1);
                    g *= (0.9 + contour*0.1);
                    b *= (0.9 + contour*0.1);
                }
            }

            // 3. Wpisanie piksela do bufora
            const index = (y * width + x) * 4;
            data[index] = r;     // R
            data[index + 1] = g; // G
            data[index + 2] = b; // B
            data[index + 3] = 255; // Alpha
        }
    }

    // Rysuj bufor na ekranie
    ctx.putImageData(imgData, 0, 0);
}

// Obsługa UI
document.querySelectorAll('input, select').forEach(el => {
    el.addEventListener('input', () => {
        // Aktualizacja labeli
        document.getElementById('val-scale').innerText = document.getElementById('scale').value;
        document.getElementById('val-oct').innerText = document.getElementById('octaves').value;
        document.getElementById('val-lines').innerText = document.getElementById('lines').value;
        document.getElementById('val-water').innerText = document.getElementById('water').value;
        draw();
    });
});

// Funkcja generująca nowe ziarno
window.generate = function() {
    seed = Math.random() * 10000;
    initSeed(); // Przelosuj tablicę permutacji
    draw();
}

// Start
initSeed();
generate();

</script>
</body>
</html>
